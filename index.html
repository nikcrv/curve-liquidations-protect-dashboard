<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.85, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>Curve Finance Liquidation Analysis Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-box-sizing: border-box;
        }
        
        html {
            overflow-x: hidden;
            width: 100%;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            width: 100%;
            position: relative;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-section {
            padding: 0;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .filter-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
            display: inline-block;
            margin-right: 15px;
        }
        
        .filter-grid {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        .filter-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        select, input[type="text"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
            transition: border-color 0.3s;
        }
        
        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .filter-buttons {
            display: inline-flex;
            gap: 8px;
            margin-left: 10px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .file-input-wrapper {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .file-input-group {
            flex: 1;
            min-width: 250px;
        }
        
        .file-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-input-btn {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .file-input-btn:hover {
            transform: translateY(-2px);
        }
        
        .file-name {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        /* Стили для объединенного контейнера */
        .combined-container {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .combined-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 45px rgba(102, 126, 234, 0.4) !important;
        }
        
        .chart-container {
            /* Стили перенесены в combined-container */
        }
        
        .chart-inner {
            background: white;
            border-radius: 12px;
            padding: 20px;
        }
        
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        
        #liquidationChart {
            width: 100%;
            height: 250px;
            position: relative;
            background: linear-gradient(to top, rgba(240,240,240,0.3) 0%, transparent 100%);
            border-radius: 8px;
            padding: 10px;
        }
        
        .chart-bar {
            position: absolute;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        
        .bar-soft {
            background: linear-gradient(180deg, rgba(76, 175, 80, 0.8) 0%, rgba(69, 160, 73, 0.8) 100%);
            width: 80%;
            position: absolute;
            left: 10%;
            bottom: 30px;
            transition: all 0.3s;
            border-radius: 3px 3px 0 0;
            box-shadow: 0 -2px 10px rgba(76, 175, 80, 0.3);
        }
        
        .bar-hard {
            background: linear-gradient(180deg, rgba(255, 107, 107, 0.9) 0%, rgba(255, 82, 82, 0.9) 100%);
            width: 80%;
            position: absolute;
            left: 10%;
            bottom: 30px;
            transition: all 0.3s;
            border-radius: 3px 3px 0 0;
            box-shadow: 0 -2px 10px rgba(255, 107, 107, 0.3);
            z-index: 2;
        }
        
        .chart-bar:hover .bar-soft {
            transform: translateY(-2px);
            box-shadow: 0 -4px 15px rgba(76, 175, 80, 0.5);
        }
        
        .chart-bar:hover .bar-hard {
            transform: translateY(-2px);
            box-shadow: 0 -4px 15px rgba(255, 107, 107, 0.5);
        }
        
        .chart-axis {
            position: absolute;
            bottom: 0;
            left: 40px;
            right: 0;
            height: 30px;
            border-top: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #666;
            padding: 5px 10px;
            background: rgba(255,255,255,0.8);
        }
        
        .chart-y-axis {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 30px;
            width: 50px;
            display: flex;
            flex-direction: column-reverse;
            justify-content: space-between;
            align-items: flex-end;
            padding: 10px 8px 10px 5px;
            font-size: 10px;
            color: #666;
            border-right: 2px solid #e0e0e0;
            background: rgba(255,255,255,0.8);
        }
        
        .chart-y-label {
            text-align: right;
            width: 100%;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid #4caf50;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: all;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid #4caf50;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: all;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        .chart-legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
            font-size: 13px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .chart-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        .stat-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.25);
        }
        
        /* Modern select and input styles */
        .modern-select:hover,
        .modern-select:focus {
            border-color: rgba(255,255,255,0.6) !important;
            background: white !important;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.2);
            outline: none;
        }
        
        select.modern-select option {
            padding: 10px;
            background: white;
            color: #333;
        }
        
        select.modern-select option:hover {
            background: #f0f0f0;
        }
        
        .stat-card.protection {
            grid-column: span 2;
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            text-align: center;
            padding: 30px;
        }
        
        .stat-card.protection.negative {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }
        
        .stat-card.protection .stat-label {
            color: rgba(255,255,255,0.9);
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .stat-card.protection .stat-value {
            font-size: 42px;
            color: white;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .protection-percent {
            font-size: 24px;
            opacity: 0.95;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 6px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 5px;
                zoom: 0.85;
                -webkit-text-size-adjust: 85%;
            }
            
            /* Stack chart and distribution on mobile */
            .chart-distribution-grid {
                grid-template-columns: 1fr !important;
                gap: 15px;
            }
            
            .container {
                padding: 0;
                width: 100%;
            }
            
            h1 {
                font-size: 20px;
                margin-bottom: 15px;
                padding: 0 5px;
            }
            
            .controls {
                padding: 8px;
                margin-bottom: 10px;
                border-radius: 8px;
            }
            
            .filter-section {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
                width: 100%;
            }
            
            .filter-title {
                font-size: 12px;
                margin-bottom: 8px;
            }
            
            .filter-label {
                font-size: 11px;
            }
            
            .filter-grid {
                width: 100%;
                flex-direction: column;
                gap: 8px;
            }
            
            .filter-group {
                width: 100%;
            }
            
            select, input[type="text"] {
                width: 100%;
                max-width: 100%;
                padding: 6px 10px;
                font-size: 13px;
            }
            
            .filter-buttons {
                width: 100%;
                flex-direction: row;
                margin-left: 0;
                margin-top: 8px;
                gap: 5px;
            }
            
            .filter-buttons .btn {
                flex: 1;
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 8px;
                margin-bottom: 10px;
            }
            
            .stat-card {
                padding: 12px;
                border-radius: 8px;
            }
            
            .stat-card.protection {
                grid-column: span 1;
                padding: 15px;
            }
            
            .stat-card.protection .stat-value {
                font-size: 28px;
            }
            
            .stat-card.protection .stat-label {
                font-size: 16px;
                margin-bottom: 8px;
                font-weight: 700;
                opacity: 1;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .protection-percent {
                font-size: 18px;
            }
            
            .stat-label {
                font-size: 10px;
                margin-bottom: 3px;
            }
            
            .stat-value {
                font-size: 18px;
            }
            
            .combined-container {
                margin: 0 -5px;
                border-radius: 10px;
                padding: 2px;
                margin-bottom: 10px;
            }
            
            .combined-container > div {
                border-radius: 8px;
                padding: 10px;
            }
            
            #liquidationChart {
                height: 180px;
                overflow: hidden;
                position: relative;
            }
            
            .chart-title {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                font-size: 12px;
            }
            
            .table-scroll-indicator {
                display: block;
                animation: slideHint 3s ease-in-out infinite;
            }
            
            @keyframes slideHint {
                0%, 100% { transform: translateX(0); }
                50% { transform: translateX(-10px); }
            }
            
            th, td {
                padding: 8px 6px;
                font-size: 11px;
            }
            
            .tabs {
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                width: 100%;
                padding-bottom: 5px;
            }
            
            .tab {
                flex: 0 0 auto;
                min-width: auto;
                white-space: nowrap;
                text-align: center;
                font-size: 11px;
                padding: 5px 10px;
            }
            
            .date-range-container {
                flex-direction: column;
                gap: 8px;
                padding: 8px;
                margin-bottom: 10px;
            }
            
            .date-display {
                width: 100%;
                justify-content: space-between;
                font-size: 12px;
            }
            
            .range-slider-container {
                width: 100%;
            }
            
            .language-toggle {
                position: fixed;
                top: 5px;
                right: 5px;
                z-index: 1000;
                transform: scale(0.9);
            }
            
            .pagination {
                padding: 10px;
                gap: 5px;
            }
            
            .pagination button {
                padding: 5px 10px;
                font-size: 12px;
            }
        }
        
        .tabs {
            display: inline-flex;
            gap: 5px;
            margin-bottom: 0;
            background: transparent;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
        }
        
        .tab {
            padding: 6px 12px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            font-weight: 500;
        }
        
        .tab:hover {
            background: #e8e8e8;
        }
        
        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }
        
        .data-table {
            background: transparent;
            border-radius: 10px;
            padding: 0 20px 20px 20px;
            overflow-x: auto;
            position: relative;
        }
        
        .table-scroll-indicator {
            display: none;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%);
            padding: 8px;
            text-align: center;
            font-size: 12px;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 5px;
            border-radius: 5px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .table-wrapper::-webkit-scrollbar {
            height: 8px;
        }
        
        .table-wrapper::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .table-wrapper::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        th.sortable {
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }
        
        th.sortable:hover {
            background: linear-gradient(135deg, #7684ec 0%, #8659b4 100%);
        }
        
        .explorer-link {
            color: #6b46a3;
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .explorer-link:hover {
            color: #764ba2;
            text-decoration: underline;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: white;
            font-size: 18px;
        }
        
        .error {
            background: #ff6b6b;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
        }
        
        .page-btn {
            padding: 8px 12px;
            background: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .page-btn:hover:not(:disabled) {
            background: #667eea;
            color: white;
        }
        
        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .page-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .page-info {
            margin: 0 10px;
            color: #666;
        }
        
        .filter-stats {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            color: #666;
            margin-left: 15px;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
            max-width: 100%;
        }
        
        .filter-stats strong {
            color: #333;
        }
        
        @media (max-width: 768px) {
            .filter-stats {
                display: block;
                margin-left: 0;
                margin-top: 10px;
                font-size: 12px;
                line-height: 1.6;
            }
        }
        
        .no-data {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 16px;
        }
        
        @media (max-width: 968px) {
            /* Переход на вертикальную компоновку для планшетов */
            .chart-inner > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }
        }
        
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .filter-grid {
                grid-template-columns: 1fr;
            }
            
            /* Вертикальная компоновка для мобильных */
            .chart-inner > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
            
            /* Адаптация контролов */
            .chart-inner > div:first-child {
                flex-direction: column;
                gap: 15px;
            }
            
            .chart-inner > div:first-child > div:last-child {
                width: 100%;
                justify-content: center !important;
            }
            
            /* Предотвращение переполнения таблиц */
            table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .data-table {
                padding: 10px;
                overflow-x: auto;
            }
            
            /* Убираем фиксированные ширины */
            .container {
                width: 100%;
                padding: 0 10px;
            }
            
            body {
                padding: 10px;
            }
            
            /* Адаптация элементов управления */
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            
            /* Сокращаем padding для карточек */
            .stat-card {
                padding: 10px;
            }
        }
        
        .date-range-picker {
            position: absolute;
            top: 40px;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            z-index: 1001;
            min-width: 280px;
        }
        
        .date-range-picker.active {
            display: block;
        }
        
        .calendar-icon {
            cursor: pointer;
            font-size: 14px;
            padding: 6px 12px;
            border-radius: 5px;
            transition: all 0.2s;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-weight: 500;
        }
        
        .calendar-icon:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }
        
        .date-input-group {
            margin-bottom: 10px;
        }
        
        .date-input-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .date-input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .date-range-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .date-range-buttons button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s;
        }
        
        .date-range-buttons button:hover {
            transform: translateY(-1px);
        }
        
        .btn-apply {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-cancel {
            background: #f0f0f0;
            color: #333;
        }
        
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            position: relative;
        }
        
        .table-wrapper {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1 style="margin: 0; display: flex; align-items: center; justify-content: center; gap: 10px;">
                <img src="curve-logo.png" alt="Curve Logo" style="height: 40px; width: auto;">
                Curve Finance Liquidation Analysis 🦙
            </h1>
            <div style="display: flex; gap: 10px;">
                <button onclick="setLanguage('en')" style="padding: 8px 16px; border: none; border-radius: 5px; background: white; cursor: pointer; font-weight: 500;" id="langEn">🇬🇧 EN</button>
                <button onclick="setLanguage('ru')" style="padding: 8px 16px; border: none; border-radius: 5px; background: rgba(255,255,255,0.2); color: white; cursor: pointer; font-weight: 500;" id="langRu">🇷🇺 RU</button>
            </div>
        </div>
        
        <div class="stats-grid" id="statsGrid"></div>
        
        <!-- Объединенный блок графика и таблиц -->
        <div class="combined-container" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%); border-radius: 15px; padding: 3px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.15); position: relative; width: 100%; max-width: 100%; overflow: hidden;">
            <div style="background: white; border-radius: 12px; padding: 20px; width: 100%; overflow-x: auto;">
                <!-- График -->
                <div class="chart-container" style="margin-bottom: 0; box-shadow: none;">
                    <div class="chart-inner">
                <!-- Header with title and controls -->
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px;">
                    <div class="chart-title" id="chartTitle" style="font-size: 18px; font-weight: 600; color: #333;">📈 Chart by Days</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end;">
                        <div style="display: flex; align-items: center; gap: 8px; padding: 4px 8px; background: #f0f0f0; border-radius: 5px; font-size: 13px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="chartPeriod" value="day" style="margin-right: 3px;">
                                <span id="dayLabel">Day</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="chartPeriod" value="week" style="margin-right: 3px;">
                                <span id="weekLabel">Week</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="chartPeriod" value="month" checked style="margin-right: 3px;">
                                <span id="monthLabel">Month</span>
                            </label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; padding: 4px 8px; background: #f0f0f0; border-radius: 5px; font-size: 13px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="chartMode" value="count" style="margin-right: 3px;">
                                <span id="countLabel">Count</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="chartMode" value="sum" checked style="margin-right: 3px;">
                                <span id="sumLabel">Sum ($)</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Main content area -->
                <div class="chart-distribution-grid" style="display: grid; grid-template-columns: 1fr 300px; gap: 20px; align-items: start;">
                    <!-- Chart area -->
                    <div style="min-height: 250px; background: #fafafa; border-radius: 8px; padding: 15px;">
                        <div id="liquidationChart"></div>
                    </div>
                    
                    <!-- Distribution pie chart -->
                    <div style="background: #fafafa; border-radius: 8px; padding: 10px;">
                        <!-- Distribution type selector -->
                        <div style="display: flex; align-items: center; gap: 8px; padding: 4px 8px; background: white; border-radius: 5px; font-size: 13px; margin-bottom: 10px; justify-content: center;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="distributionType" value="token" checked style="margin-right: 3px;">
                                <span id="tokenBtnText2">Tokens</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="distributionType" value="platform" style="margin-right: 3px;">
                                <span id="platformBtnText2">Platforms</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="radio" name="distributionType" value="network" style="margin-right: 3px;">
                                <span id="networkBtnText2">Networks</span>
                            </label>
                        </div>
                        <div style="height: 224px; display: flex; align-items: center; justify-content: center;">
                            <canvas id="distributionChart" width="280" height="260"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- Range slider -->
                <div class="chart-controls" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                    <div style="position: relative; width: 100%; height: 30px; margin: 10px 0;">
                        <div style="position: absolute; width: 100%; height: 4px; background: #e0e0e0; border-radius: 2px; top: 13px;"></div>
                        <div id="sliderRange" style="position: absolute; height: 4px; background: linear-gradient(90deg, #4caf50 0%, #45a049 100%); border-radius: 2px; top: 13px;"></div>
                        <input type="range" id="rangeStart" min="0" max="1000" value="0" step="1" style="position: absolute; width: 100%; height: 4px; background: transparent; pointer-events: none; -webkit-appearance: none; top: 13px;">
                        <input type="range" id="rangeEnd" min="0" max="1000" value="30" step="1" style="position: absolute; width: 100%; height: 4px; background: transparent; pointer-events: none; -webkit-appearance: none; top: 13px;">
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 12px; color: #666;">
                        <span id="startLabel" onclick="openDatePicker('start')" style="padding: 2px 6px; background: #fff; border-radius: 3px; font-weight: 500; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='#fff'">Начало</span>
                        <span id="selectedPeriodLabel" style="color: #999; font-size: 11px;">Выбранный период</span>
                        <span id="endLabel" onclick="openDatePicker('end')" style="padding: 2px 6px; background: #fff; border-radius: 3px; font-weight: 500; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='#fff'">Конец</span>
                    </div>
                </div>
                    </div>
                </div>
                
                <!-- Календарь для выбора даты -->
                <div id="datePickerPopup" style="position: absolute; background: white; border: 1px solid #ddd; border-radius: 8px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; z-index: 10000;">
                    <input type="date" id="datePickerInput" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <div style="margin-top: 10px; display: flex; gap: 5px;">
                        <button id="applyDateBtn" onclick="applyDateFromPicker()" style="padding: 6px 12px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">Применить</button>
                        <button id="cancelDateBtn" onclick="closeDatePicker()" style="padding: 6px 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Отмена</button>
                    </div>
                </div>
                
                <!-- Таблица -->
                <div class="data-table" id="dataTable" style="margin-bottom: 0; box-shadow: none; padding-top: 0;">
                    <div class="loading" id="loadingText">Loading data...</div>
                </div>
                
                <div class="pagination" id="pagination" style="display: none; margin-top: 15px;"></div>
            </div>
        </div>
        
        <div class="chart-tooltip" id="chartTooltip"></div>
        <div id="chartsSection" style="display: none;"></div>
    </div>

    <script>
        // Language system
        let currentLang = localStorage.getItem('liquidationLang') || 'en';
        
        const translations = {
            en: {
                title: 'Curve Finance Liquidation Protection Analysis 🦙',
                softLiquidations: 'In Liquidation Protection Mode',
                hardLiquidations: 'Hard Liquidations',
                comparison: 'Comparison',
                swipeToScroll: 'Swipe to scroll',
                filters: 'Filters',
                platform: 'Platform',
                allPlatforms: 'All Platforms',
                network: 'Network',
                allNetworks: 'All Networks',
                token: 'Token',
                allTokens: 'All Tokens',
                market: 'Market',
                user: 'User',
                liquidator: 'Liquidator',
                debt: 'Debt',
                discount: 'Discount',
                date: 'Date',
                dateAndTime: 'Date and Time',
                dateFilter: 'Date Filter',
                applyFilters: 'Apply Filters',
                resetFilters: 'Reset',
                chartByDays: 'Analysis for Period',
                day: 'Day',
                week: 'Week',
                month: 'Month',
                count: 'Positions',
                sum: 'Size ($)',
                start: 'Start',
                end: 'End',
                maxTVL: 'Max TVL',
                txHash: 'Tx Hash',
                noData: 'No data',
                noEventsMatchingFilters: 'No events matching filters',
                noPositionsMatchingFilters: 'No positions matching filters',
                showing: 'Showing',
                of: 'of',
                softLiquidationsCount: 'soft liquidations',
                hardLiquidationsCount: 'hard liquidations',
                byMarkets: 'By Markets',
                byPlatforms: 'By Platforms',
                byTokens: 'By Tokens',
                byNetworks: 'By Networks',
                softPositions: 'Soft Positions',
                hardEvents: 'Hard Events',
                totalSoftTVL: 'Total Soft TVL',
                totalHardDebt: 'Total Hard Debt',
                apply: 'Apply',
                cancel: 'Cancel',
                selectValidDate: 'Please select a valid date',
                softLiquidationsInPositions: 'Positions in Liquidation Protection Mode (in soft liquidation)',
                dateFrom: 'From',
                dateTo: 'To',
                loadingData: 'Loading data...',
                averageSize: 'Average size',
                liquidationsPerUser: 'Liquidations per user',
                averageDiscount: 'Average discount',
                softPositionsCount: 'Soft positions',
                totalTVL: 'Total TVL',
                debtWithoutDiscount: 'Debt without discount',
                debtWithDiscount: 'Debt with discount',
                events: 'Events',
                hardLiquidationsLabel: '🔥 HARD LIQUIDATIONS',
                quickFilters: '⚡ Quick Filters',
                positions: 'positions',
                protectedFromLiquidation: '🛡️ PROTECTED FROM LIQUIDATION',
                protectionStatus: 'Protection Status',
                platformDistribution: 'Platform Distribution',
                networkDistribution: 'Network Distribution', 
                tokenDistribution: 'Token Distribution',
                ofTVLInSoft: 'of TVL in liquidation protection<br>(soft liquidation)',
                softLiquidationsLabel: '💧 SOFT LIQUIDATIONS',
                positionsLabel: 'Positions',
                totalDebt: 'Total debt',
                averageLTV: 'Average LTV',
                positionsPerUser: 'Positions per user',
                averagePosition: 'Average position',
                protected: 'Protected',
                chain: 'Chain',
                softDebt: 'Soft Debt',
                addressPlaceholder: 'Address (0x...)',
                pageText: 'Page',
                ofPages: 'of',
                records: 'records',
                selectedPeriod: 'Selected period',
                others: 'Others',
                tokens: 'Tokens',
                platforms: 'Platforms',
                networks: 'Networks',
                value: 'Value',
                share: 'Share',
                includes: 'Includes',
                andMore: 'and {count} more'
            },
            ru: {
                title: 'Анализ защиты от ликвидаций Curve Finance 🦙',
                softLiquidations: 'В режиме защиты от ликвидации',
                hardLiquidations: 'Жёсткие ликвидации',
                comparison: 'Сравнение',
                swipeToScroll: 'Смахните для прокрутки',
                filters: 'Фильтры',
                platform: 'Платформа',
                allPlatforms: 'Все платформы',
                network: 'Сеть',
                allNetworks: 'Все сети',
                token: 'Токен',
                allTokens: 'Все токены',
                market: 'Маркет',
                user: 'Пользователь',
                liquidator: 'Ликвидатор',
                debt: 'Долг',
                discount: 'Дисконт',
                date: 'Дата',
                dateAndTime: 'Дата и время',
                dateFilter: 'Фильтр по дате',
                applyFilters: 'Применить фильтры',
                resetFilters: 'Сбросить',
                chartByDays: 'Анализ за период',
                day: 'День',
                week: 'Неделя',
                month: 'Месяц',
                count: 'Позиций',
                sum: 'Размер ($)',
                start: 'Начало',
                end: 'Конец',
                maxTVL: 'Max TVL',
                txHash: 'Tx Hash',
                noData: 'Нет данных',
                noEventsMatchingFilters: 'Нет событий, соответствующих фильтрам',
                noPositionsMatchingFilters: 'Нет позиций, соответствующих фильтрам',
                showing: 'Показано',
                of: 'из',
                softLiquidationsCount: 'софт ликвидаций',
                hardLiquidationsCount: 'хард ликвидаций',
                byMarkets: 'По маркетам',
                byPlatforms: 'По платформам',
                byTokens: 'По токенам',
                byNetworks: 'По сетям',
                softPositions: 'Софт позиции',
                hardEvents: 'Хард события',
                totalSoftTVL: 'Общий софт TVL',
                totalHardDebt: 'Общий хард долг',
                apply: 'Применить',
                cancel: 'Отмена',
                selectValidDate: 'Пожалуйста, выберите корректную дату',
                softLiquidationsInPositions: 'Позиции в режиме защиты от ликвидации (в софт ликвидации)',
                dateFrom: 'От',
                dateTo: 'До',
                loadingData: 'Загрузка данных...',
                averageSize: 'Средний размер',
                liquidationsPerUser: 'Ликвидаций на юзера',
                averageDiscount: 'Средний дисконт',
                softPositionsCount: 'Софт позиций',
                totalTVL: 'Общий TVL',
                debtWithoutDiscount: 'Долг без дисконта',
                debtWithDiscount: 'Долг с дисконтом',
                events: 'Событий',
                hardLiquidationsLabel: '🔥 ХАРД ЛИКВИДАЦИИ',
                quickFilters: '⚡ Быстрые фильтры',
                positions: 'позиций',
                protectedFromLiquidation: '🛡️ ЗАЩИЩЕНО ОТ ЛИКВИДАЦИИ',
                protectionStatus: 'Статус защиты',
                platformDistribution: 'Распределение по платформам',
                networkDistribution: 'Распределение по сетям',
                tokenDistribution: 'Распределение по токенам',
                ofTVLInSoft: 'от TVL в диапазоне защиты<br>(в софт ликвидации)',
                softLiquidationsLabel: '💧 СОФТ ЛИКВИДАЦИИ',
                positionsLabel: 'Позиций',
                totalDebt: 'Общий долг',
                averageLTV: 'Средний LTV',
                positionsPerUser: 'Позиций на юзера',
                averagePosition: 'Средняя позиция',
                protected: 'Защищено',
                chain: 'Сеть',
                softDebt: 'Софт долг',
                addressPlaceholder: 'Адрес (0x...)',
                pageText: 'Страница',
                ofPages: 'из',
                records: 'записей',
                selectedPeriod: 'Выбранный период',
                others: 'Остальные',
                tokens: 'Токены',
                platforms: 'Платформы',
                networks: 'Сети',
                value: 'Сумма',
                share: 'Доля',
                includes: 'Включает',
                andMore: 'и еще {count}'
            }
        };
        
        function t(key) {
            return translations[currentLang][key] || key;
        }
        
        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('liquidationLang', lang);
            
            // Update button styles
            const enBtn = document.getElementById('langEn');
            const ruBtn = document.getElementById('langRu');
            if (lang === 'en') {
                enBtn.style.background = 'white';
                enBtn.style.color = '#333';
                ruBtn.style.background = 'rgba(255,255,255,0.2)';
                ruBtn.style.color = 'white';
            } else {
                ruBtn.style.background = 'white';
                ruBtn.style.color = '#333';
                enBtn.style.background = 'rgba(255,255,255,0.2)';
                enBtn.style.color = 'white';
            }
            
            updateUILanguage();
            renderStats();
            // Update the inline protection chart after stats are rendered
            setTimeout(() => updateProtectionChartInline(), 100);  // Add this to update stats when language changes
            renderData();
            renderChart();  // Fixed: was updateChart, should be renderChart
            updateFilters();
            updateFilterOptions();  // Update filter dropdown options when language changes
            updateFilterStats();  // Update filter stats text when language changes
        }
        
        function updateUILanguage() {
            // Update static texts
            const h1 = document.querySelector('h1');
            if (h1) {
                // Keep the image and update only the text
                h1.innerHTML = `
                    <img src="curve-logo.png" alt="Curve Logo" style="height: 40px; width: auto;">
                    ${t('title')}
                `;
            }
            const chartTitle = document.querySelector('#chartTitle');
            if (chartTitle) chartTitle.textContent = `📈 ${t('chartByDays')}`;
            
            // Обновляем формат дат при смене языка, но не меняем сами даты
            const startLabel = document.querySelector('#startLabel');
            const endLabel = document.querySelector('#endLabel');
            const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
            
            if (startLabel && selectedStartDate) {
                startLabel.textContent = selectedStartDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
            }
            if (endLabel && selectedEndDate) {
                endLabel.textContent = selectedEndDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
            }
            
            // Update chart period labels
            const dayLabel = document.querySelector('#dayLabel');
            if (dayLabel) dayLabel.textContent = t('day');
            const weekLabel = document.querySelector('#weekLabel');
            if (weekLabel) weekLabel.textContent = t('week');
            const monthLabel = document.querySelector('#monthLabel');
            if (monthLabel) monthLabel.textContent = t('month');
            
            // Update filter texts
            const filterTitle = document.querySelector('#filterTitle');
            if (filterTitle) filterTitle.textContent = `🔍 ${t('filters')}:`;
            const applyBtn = document.querySelector('#applyFiltersBtn');
            if (applyBtn) applyBtn.textContent = t('apply');
            const resetBtn = document.querySelector('#resetFiltersBtn');
            if (resetBtn) resetBtn.textContent = t('resetFilters').replace('Filters', '');
            
            // Update platform filter
            const allPlatformsOption = document.querySelector('#allPlatformsOption');
            if (allPlatformsOption) allPlatformsOption.textContent = t('allPlatforms');
            
            // Update address placeholder
            const addressFilter = document.querySelector('#addressFilter');
            if (addressFilter) addressFilter.placeholder = t('addressPlaceholder');
            const allNetworks = document.querySelector('#allNetworksOption');
            if (allNetworks) allNetworks.textContent = t('allNetworks');
            const allTokens = document.querySelector('#allTokensOption');
            if (allTokens) allTokens.textContent = t('allTokens');
            
            // Update selected period label
            const selectedPeriodLabel = document.querySelector('#selectedPeriodLabel');
            if (selectedPeriodLabel) selectedPeriodLabel.textContent = t('selectedPeriod');
            
            // Update distribution chart buttons
            // Update both sets of buttons
            const tokenBtnText = document.querySelector('#tokenBtnText');
            if (tokenBtnText) tokenBtnText.textContent = t('tokens');
            const tokenBtnText2 = document.querySelector('#tokenBtnText2');
            if (tokenBtnText2) tokenBtnText2.textContent = t('tokens');
            
            const platformBtnText = document.querySelector('#platformBtnText');
            if (platformBtnText) platformBtnText.textContent = t('platforms');
            const platformBtnText2 = document.querySelector('#platformBtnText2');
            if (platformBtnText2) platformBtnText2.textContent = t('platforms');
            
            const networkBtnText = document.querySelector('#networkBtnText');
            if (networkBtnText) networkBtnText.textContent = t('networks');
            const networkBtnText2 = document.querySelector('#networkBtnText2');
            if (networkBtnText2) networkBtnText2.textContent = t('networks');
            
            // Update main date filter
            const mainDateFilterBtn = document.querySelector('#mainDateFilterBtn');
            if (mainDateFilterBtn) mainDateFilterBtn.innerHTML = `📅 ${t('dateFilter')}`;
            const mainDateFromLabel = document.querySelector('#mainDateFromLabel');
            if (mainDateFromLabel) mainDateFromLabel.textContent = `${t('dateFrom')}:`;
            const mainDateToLabel = document.querySelector('#mainDateToLabel');
            if (mainDateToLabel) mainDateToLabel.textContent = `${t('dateTo')}:`;
            const mainApplyBtn = document.querySelector('#mainApplyBtn');
            if (mainApplyBtn) mainApplyBtn.textContent = t('apply');
            const mainCancelBtn = document.querySelector('#mainCancelBtn');
            if (mainCancelBtn) mainCancelBtn.textContent = t('cancel');
            
            // Update tabs
            document.querySelectorAll('.tab').forEach(tab => {
                const tabType = tab.dataset.tab;
                if (tabType === 'soft') tab.innerHTML = `💧 ${t('softLiquidations')}`;
                if (tabType === 'hard') tab.innerHTML = `🔥 ${t('hardLiquidations')}`;
                if (tabType === 'comparison') tab.innerHTML = `📊 ${t('comparison')}`;
            });
            
            // Update legend
            const legendItems = document.querySelectorAll('.legend-item span');
            if (legendItems[0]) legendItems[0].textContent = t('softLiquidations');
            if (legendItems[1]) legendItems[1].textContent = t('hardLiquidations');
            
            // Update radio buttons for chart mode
            const countLabel = document.getElementById('countLabel');
            const sumLabel = document.getElementById('sumLabel');
            if (countLabel) countLabel.textContent = t('count');
            if (sumLabel) sumLabel.textContent = t('sum');
            
            // Update loading text
            const loadingEl = document.querySelector('#loadingText');
            if (loadingEl) loadingEl.textContent = t('loadingData');
        }
        
        function updateFilters() {
            // This function is called when language changes to update filter options
            updateUILanguage();
        }
        
        let softData = null;
        let hardData = null;
        let filteredSoftData = null;
        let filteredHardData = null;
        let currentTab = 'comparison';
        let currentPage = 1;
        const itemsPerPage = 50;
        let availableNetworks = new Set();
        let availableTokens = new Set();
        let sortColumn = 'first_dt'; // По умолчанию сортируем по дате входа
        let sortDirection = 'desc'; // По умолчанию новые сначала
        let hardSortColumn = 'timestamp'; // Сортировка для хард ликвидаций
        let hardSortDirection = 'desc';
        let compareSortColumn = 'softTVL'; // Сортировка для сравнения
        let compareSortDirection = 'desc';
        
        // Глобальные переменные для хранения выбранных дат
        let selectedStartDate = null;
        let selectedEndDate = null;
        let globalMinDate = null;
        let globalMaxDate = null;
        let chartMode = 'sum'; // 'count' или 'sum'
        let chartPeriod = 'month'; // 'day', 'week', 'month'
        let comparisonGroupBy = 'market'; // 'market', 'platform', 'token', 'chain'
        let tableDateStart = null; // Начальная дата для фильтрации таблиц
        let tableDateEnd = null; // Конечная дата для фильтрации таблиц

        // Удален обработчик выбора файла - автозагрузка из latest_liquidations_final.js

        // Обработка вкладок
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                currentTab = e.target.dataset.tab;
                currentPage = 1;
                renderData();
            });
        });
        
        // Обработка переключения режима графика
        document.addEventListener('DOMContentLoaded', () => {
            // Don't initialize language here - wait until data is loaded
            
            document.querySelectorAll('input[name="chartMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    chartMode = e.target.value;
                    renderChart();
                    // Also update distribution chart
                    updateDistributionCharts();
                });
            });
            
            // Обработчик для периода графика
            document.querySelectorAll('input[name="chartPeriod"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    chartPeriod = e.target.value;
                    renderChart();
                });
            });

            // Обработчик для типа диаграммы распределения
            document.querySelectorAll('input[name="distributionType"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    switchDistributionChart(e.target.value);
                });
            });
            
            // Закрытие календаря при клике вне его
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.date-range-picker') && !e.target.closest('.calendar-icon')) {
                    document.querySelectorAll('.date-range-picker').forEach(picker => {
                        picker.classList.remove('active');
                    });
                }
            });
        });

        async function loadFile(file) {
            try {
                const text = await file.text();
                
                // Извлекаем JSON из JSONP
                const jsonMatch = text.match(/window\.\w+\s*=\s*({[\s\S]*});?\s*$/);
                if (!jsonMatch) {
                    throw new Error('Неверный формат JSONP файла');
                }
                
                const data = JSON.parse(jsonMatch[1]);
                processLoadedData(data);
            } catch (error) {
                showError(`Ошибка загрузки файла: ${error.message}`);
            }
        }

        async function loadScriptByName(fileName) {
            return new Promise((resolve, reject) => {
                // Удаляем старый скрипт если есть
                const oldScript = document.getElementById('dataScript');
                if (oldScript) {
                    oldScript.remove();
                }
                
                const script = document.createElement('script');
                script.id = 'dataScript';
                script.src = fileName + '?t=' + Date.now(); // Добавляем timestamp для обхода кеша
                script.onload = resolve;
                script.onerror = () => reject(new Error('Не удалось загрузить файл'));
                document.body.appendChild(script);
            });
        }

        // Предварительно обработанные данные для быстрого доступа
        let preprocessedData = {
            dailyPositions: {}, // Позиции активные в каждый день
            weeklyPositions: {}, // Позиции активные в каждую неделю
            monthlyPositions: {}, // Позиции активные в каждый месяц
            dailyEvents: {}, // События по дням
            weeklyEvents: {}, // События по неделям
            monthlyEvents: {}, // События по месяцам
            minDate: null,
            maxDate: null
        };
        
        // Функция предварительной обработки данных
        function preprocessData() {
            const startTime = performance.now();
            
            // Находим диапазон дат
            let minDate = new Date('2100-01-01');
            let maxDate = new Date('2000-01-01');
            
            // Обрабатываем софт ликвидации
            if (softData && softData.positions) {
                softData.positions.forEach(pos => {
                    if (pos.first_dt) {
                        const openDate = new Date(pos.first_dt);
                        const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                        
                        if (openDate < minDate) minDate = openDate;
                        if (closeDate > maxDate) maxDate = closeDate;
                        
                        // Предварительно вычисляем TVL
                        pos.cachedTVL = parseFloat(pos.tvl || pos.collateral_usd || 0);
                    }
                });
            }
            
            // Обрабатываем хард ликвидации
            if (hardData && hardData.events) {
                hardData.events.forEach(event => {
                    if (event.timestamp) {
                        const date = new Date(event.timestamp);
                        if (date < minDate) minDate = date;
                        if (date > maxDate) maxDate = date;
                        
                        // Предварительно вычисляем debt
                        event.cachedDebt = parseFloat(event.debt_with_discount || event.debt || 0);
                    }
                });
            }
            
            preprocessedData.minDate = minDate;
            preprocessedData.maxDate = maxDate;
            
            // Создаём индексы по дням
            const currentDate = new Date(minDate);
            while (currentDate <= maxDate) {
                const dayKey = currentDate.toISOString().split('T')[0];
                preprocessedData.dailyPositions[dayKey] = [];
                preprocessedData.dailyEvents[dayKey] = [];
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            // Заполняем индексы позициями
            if (softData && softData.positions) {
                softData.positions.forEach((pos, index) => {
                    if (pos.first_dt) {
                        const openDate = new Date(pos.first_dt);
                        const closeDate = pos.last_dt ? new Date(pos.last_dt) : maxDate;
                        
                        // Добавляем позицию во все дни когда она была активна
                        let currentDate = new Date(openDate);
                        while (currentDate <= closeDate) {
                            const dayKey = currentDate.toISOString().split('T')[0];
                            if (preprocessedData.dailyPositions[dayKey]) {
                                preprocessedData.dailyPositions[dayKey].push(index);
                            }
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                    }
                });
            }
            
            // Заполняем индексы событиями
            if (hardData && hardData.events) {
                hardData.events.forEach((event, index) => {
                    if (event.timestamp) {
                        const date = new Date(event.timestamp);
                        const dayKey = date.toISOString().split('T')[0];
                        if (preprocessedData.dailyEvents[dayKey]) {
                            preprocessedData.dailyEvents[dayKey].push(index);
                        }
                    }
                });
            }
            
            const endTime = performance.now();
        }

        function processLoadedData(data) {
            softData = data.soft_liquidations;
            hardData = data.hard_liquidations;
            
            // Initialize filtered data to be the same as original data
            filteredSoftData = softData;
            filteredHardData = hardData;
            
            // Предварительная обработка данных для оптимизации
            preprocessData();
            
            // Находим полный диапазон данных
            let minDate = new Date();
            let maxDate = new Date(0);
            
            // Собираем доступные сети и токены
            availableNetworks.clear();
            availableTokens.clear();
            
            // Из софт ликвидаций
            if (softData && softData.positions) {
                softData.positions.forEach(pos => {
                    if (pos.chain) availableNetworks.add(pos.chain);
                    if (pos.collateral_token) availableTokens.add(pos.collateral_token);
                    if (pos.first_dt) {
                        const date = new Date(pos.first_dt);
                        if (date < minDate) minDate = date;
                        if (date > maxDate) maxDate = date;
                    }
                });
            }
            
            // Из хард ликвидаций
            if (hardData && hardData.events) {
                hardData.events.forEach(event => {
                    if (event.chain) availableNetworks.add(event.chain);
                    if (event.collateral_token) availableTokens.add(event.collateral_token);
                    if (event.timestamp) {
                        const date = new Date(event.timestamp);
                        if (date < minDate) minDate = date;
                        if (date > maxDate) maxDate = date;
                    }
                });
            }
            
            // Сохраняем глобальные даты
            globalMinDate = minDate;
            globalMaxDate = maxDate;
            
            // Устанавливаем диапазон ползунков на весь период данных
            const totalDays = Math.ceil((maxDate - minDate) / (24 * 60 * 60 * 1000));
            const rangeStart = document.getElementById('rangeStart');
            const rangeEnd = document.getElementById('rangeEnd');
            const sliderRange = document.getElementById('sliderRange');
            
            // Устанавливаем максимум на полный диапазон данных
            rangeStart.max = totalDays;
            rangeEnd.max = totalDays;
            rangeStart.value = 0; // Начало с первого дня
            rangeEnd.value = totalDays; // Конец на последней дате
            
            // Обновляем визуальный диапазон
            const startPercent = 0;
            const endPercent = 100;
            sliderRange.style.left = startPercent + '%';
            sliderRange.style.width = endPercent + '%';
            
            // Устанавливаем начальные выбранные даты на весь диапазон
            selectedStartDate = minDate;
            selectedEndDate = maxDate;
            
            // Обновляем метки
            const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
            document.getElementById('startLabel').textContent = selectedStartDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
            document.getElementById('endLabel').textContent = selectedEndDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
            
            // Обрабатываем и отображаем данные (this will create the filter elements in the stats grid)
            processData();
            
            // Initialize language UI and update filter options after elements are created
            setTimeout(() => {
                updateUILanguage();
                updateFilterOptions();
                
                // Force update dropdowns again after a delay to ensure they're populated
                setTimeout(() => {
                    updateFilterOptions();
                }, 100);
            }, 20);
            
            // Применяем фильтры после того как элементы созданы
            setTimeout(() => {
                applyFilters();
            }, 150);
            
            // Force update filter stats with current language and date range
            setTimeout(() => {
                updateFilterStats();
                updateProtectionChart();
            }, 100);
            
            // Final attempt to populate dropdowns after everything is ready
            setTimeout(() => {
                updateFilterOptions();
            }, 500);
        }

        function updateFilterOptions() {
            // Function to try updating filters with retries
            let retryCount = 0;
            const maxRetries = 10;
            
            function tryUpdate() {
                // Обновляем сети
                const networkFilter = document.getElementById('networkFilter');
                const tokenFilter = document.getElementById('tokenFilter');
                
                let networkUpdated = false;
                let tokenUpdated = false;
                
                if (networkFilter && availableNetworks.size > 0) {
                    // Check if already populated
                    if (networkFilter.options.length <= 1) {
                        networkFilter.innerHTML = `<option value="">${t('allNetworks')}</option>`;
                        Array.from(availableNetworks).sort().forEach(network => {
                            const option = document.createElement('option');
                            option.value = network;
                            option.textContent = network;
                            networkFilter.appendChild(option);
                        });
                    }
                    networkUpdated = true;
                }
                
                // Обновляем токены
                if (tokenFilter && availableTokens.size > 0) {
                    // Check if already populated
                    if (tokenFilter.options.length <= 1) {
                        tokenFilter.innerHTML = `<option value="">${t('allTokens')}</option>`;
                        Array.from(availableTokens).sort().forEach(token => {
                            const option = document.createElement('option');
                            option.value = token;
                            option.textContent = token;
                            tokenFilter.appendChild(option);
                        });
                    }
                    tokenUpdated = true;
                }
                
                // Retry if not successful and under retry limit
                if ((!networkUpdated || !tokenUpdated) && retryCount < maxRetries) {
                    retryCount++;
                    setTimeout(tryUpdate, 200);
                }
            }
            
            tryUpdate();
        }
        
        // Helper functions for calculating summaries
        function calculateSoftSummary(positions) {
            if (!positions || positions.length === 0) {
                return {
                    total_positions: 0,
                    total_tvl: 0,
                    total_debt: 0,
                    llamalend_positions: 0,
                    llamalend_tvl: 0,
                    llamalend_debt: 0,
                    crvusd_positions: 0,
                    crvusd_tvl: 0,
                    crvusd_debt: 0
                };
            }
            
            const summary = {
                total_positions: positions.length,
                total_tvl: 0,
                total_debt: 0,
                llamalend_positions: 0,
                llamalend_tvl: 0,
                llamalend_debt: 0,
                crvusd_positions: 0,
                crvusd_tvl: 0,
                crvusd_debt: 0
            };
            
            positions.forEach(pos => {
                const tvl = parseFloat(pos.tvl || pos.collateral_usd || 0);
                const debt = parseFloat(pos.debt || 0);
                
                summary.total_tvl += tvl;
                summary.total_debt += debt;
                
                if (pos.platform === 'LlamaLend') {
                    summary.llamalend_positions++;
                    summary.llamalend_tvl += tvl;
                    summary.llamalend_debt += debt;
                } else if (pos.platform === 'crvUSD') {
                    summary.crvusd_positions++;
                    summary.crvusd_tvl += tvl;
                    summary.crvusd_debt += debt;
                }
            });
            
            return summary;
        }
        
        function calculateHardTotal(events) {
            if (!events || events.length === 0) {
                return {
                    count: 0,
                    debt: 0,
                    debt_with_discount: 0
                };
            }
            
            const total = {
                count: events.length,
                debt: 0,
                debt_with_discount: 0
            };
            
            events.forEach(event => {
                const debt = parseFloat(event.debt || 0);
                total.debt += debt;
                // Используем готовое значение debt_with_discount из JSON
                total.debt_with_discount += parseFloat(event.debt_with_discount || event.debt || 0);
            });
            
            return total;
        }

        window.switchTab = function(tab) {
            currentTab = tab;
            
            // Update main tabs
            const tabs = document.querySelectorAll('.tabs .tab');
            tabs.forEach(t => {
                t.classList.remove('active');
                if (t.dataset.tab === tab) {
                    t.classList.add('active');
                }
            });
            
            // Update tab content
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
                if (content.id === `${tab}Tab`) {
                    content.classList.add('active');
                }
            });
            
            // Update stats and re-render data
            renderStats();
            renderData();
        }
        
        window.applyFilters = function() {
            const typeFilter = 'all'; // Убрали фильтр по типу
            
            const platformFilter = document.getElementById('platformFilter');
            const networkFilter = document.getElementById('networkFilter');
            const tokenFilter = document.getElementById('tokenFilter');
            const addressFilterEl = document.getElementById('addressFilter');
            
            // Сохраняем текущие значения фильтров перед пересозданием
            const platformFilterValue = platformFilter ? platformFilter.value : '';
            const networkFilterValue = networkFilter ? networkFilter.value : '';
            const tokenFilterValue = tokenFilter ? tokenFilter.value : '';
            const addressFilter = addressFilterEl ? addressFilterEl.value.toLowerCase() : '';
            
            // Сохраняем значения глобально для восстановления после renderStats
            window.savedFilterValues = {
                platform: platformFilterValue,
                network: networkFilterValue,
                token: tokenFilterValue,
                address: addressFilterEl ? addressFilterEl.value : ''
            };
            
            // Фильтруем софт ликвидации
            if (softData && softData.positions) {
                filteredSoftData = {
                    ...softData,
                    positions: softData.positions.filter(pos => {
                        if (platformFilterValue && platformFilterValue !== '' && pos.platform !== platformFilterValue) return false;
                        if (networkFilterValue && networkFilterValue !== '' && pos.chain !== networkFilterValue) return false;
                        if (tokenFilterValue && tokenFilterValue !== '' && pos.collateral_token.toLowerCase() !== tokenFilterValue.toLowerCase()) return false;
                        if (addressFilter && !pos.user.toLowerCase().includes(addressFilter)) return false;
                        return true;
                    })
                };
                
                // Recalculate summary for filtered data
                filteredSoftData.summary = calculateSoftSummary(filteredSoftData.positions);
                
                // Keep original summary if it exists and we haven't calculated a new one
                if (!filteredSoftData.summary.total_positions && softData.summary) {
                    filteredSoftData.summary = softData.summary;
                }
            }
            
            // Фильтруем хард ликвидации
            if (hardData && hardData.events) {
                filteredHardData = {
                    ...hardData,
                    events: hardData.events.filter(event => {
                        if (platformFilterValue && platformFilterValue !== '' && event.platform !== platformFilterValue) return false;
                        if (networkFilterValue && networkFilterValue !== '' && event.chain !== networkFilterValue) return false;
                        if (tokenFilterValue && tokenFilterValue !== '' && event.collateral_token.toLowerCase() !== tokenFilterValue.toLowerCase()) return false;
                        if (addressFilter && !event.user.toLowerCase().includes(addressFilter) && 
                            !event.liquidator.toLowerCase().includes(addressFilter)) return false;
                        return true;
                    })
                };
                
                // Recalculate total for filtered data
                filteredHardData.total = calculateHardTotal(filteredHardData.events);
                
                // Keep original total if it exists and we haven't calculated a new one
                if (!filteredHardData.total.count && hardData.total) {
                    filteredHardData.total = hardData.total;
                }
            }
            
            // Update inline protection chart
            setTimeout(() => updateProtectionChartInline(), 100);
            
            // Обновляем статистику фильтров
            setTimeout(() => updateFilterStats(), 0);  // Defer to ensure DOM is ready
            
            // Сбрасываем на первую страницу
            currentPage = 1;
            
            // Применяем фильтр типа к текущей вкладке
            if (typeFilter === 'soft') {
                currentTab = 'soft';
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector('[data-tab="soft"]').classList.add('active');
            } else if (typeFilter === 'hard') {
                currentTab = 'hard';
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector('[data-tab="hard"]').classList.add('active');
            }
            
            // Обновляем статистику, диаграмму и данные
            renderStats();
            // Update the inline protection chart after stats are rendered
            setTimeout(() => updateProtectionChartInline(), 100);
            
            // Обновляем диапазон слайдера при фильтрации, но сохраняем выбранные даты
            if (filteredSoftData && filteredHardData) {
                let minDate = new Date();
                let maxDate = new Date(0);
                
                // Находим новый диапазон дат в отфильтрованных данных
                if (filteredSoftData.positions) {
                    filteredSoftData.positions.forEach(pos => {
                        if (pos.first_dt) {
                            const date = new Date(pos.first_dt);
                            if (date < minDate) minDate = date;
                            if (date > maxDate) maxDate = date;
                        }
                    });
                }
                
                if (filteredHardData.events) {
                    filteredHardData.events.forEach(event => {
                        if (event.timestamp) {
                            const date = new Date(event.timestamp);
                            if (date < minDate) minDate = date;
                            if (date > maxDate) maxDate = date;
                        }
                    });
                }
                
                // Если отфильтрованных данных нет, используем глобальный диапазон
                if (minDate > maxDate) {
                    minDate = globalMinDate;
                    maxDate = globalMaxDate;
                }
                
                // Обновляем слайдеры
                const totalDays = Math.ceil((maxDate - minDate) / (24 * 60 * 60 * 1000)) + 1;
                const rangeStart = document.getElementById('rangeStart');
                const rangeEnd = document.getElementById('rangeEnd');
                const sliderRange = document.getElementById('sliderRange');
                
                rangeStart.max = totalDays;
                rangeEnd.max = totalDays;
                
                // Пересчитываем позиции слайдера на основе сохраненных дат
                // Если выбранные даты выходят за пределы нового диапазона, корректируем их
                let newStartDate = selectedStartDate;
                let newEndDate = selectedEndDate;
                
                if (newStartDate < minDate) newStartDate = minDate;
                if (newEndDate > maxDate) newEndDate = maxDate;
                if (newStartDate > maxDate) newStartDate = new Date(maxDate.getTime() - 30 * 24 * 60 * 60 * 1000);
                if (newEndDate < minDate) newEndDate = minDate;
                
                // Конвертируем даты обратно в значения слайдера
                const startValue = Math.max(0, Math.floor((newStartDate - minDate) / (24 * 60 * 60 * 1000)));
                const endValue = Math.min(totalDays, Math.ceil((newEndDate - minDate) / (24 * 60 * 60 * 1000)));
                
                rangeStart.value = startValue;
                rangeEnd.value = endValue;
                
                // Обновляем визуальный диапазон
                const startPercent = (rangeStart.value / rangeEnd.max) * 100;
                const endPercent = (rangeEnd.value / rangeEnd.max) * 100;
                sliderRange.style.left = startPercent + '%';
                sliderRange.style.width = (endPercent - startPercent) + '%';
                
                // Обновляем метки
                const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
                document.getElementById('startLabel').textContent = newStartDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
                document.getElementById('endLabel').textContent = newEndDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
            }
            
            renderChart();
            renderData();
        }

        function updateFilterStats() {
            // This function is no longer needed as we removed the filter stats display
            // Keeping it as empty function to avoid breaking existing calls
        }

        function resetFilters() {
            // Clear saved filter values
            window.savedFilterValues = {
                platform: '',
                network: '',
                token: '',
                address: ''
            };
            
            // Clear filter elements
            document.getElementById('platformFilter').value = '';
            document.getElementById('networkFilter').value = '';
            document.getElementById('tokenFilter').value = '';
            document.getElementById('addressFilter').value = '';
            
            applyFilters();
        }

        function processData() {
            renderStats();
            // Update the inline protection chart after stats are rendered
            setTimeout(() => updateProtectionChartInline(), 100);
            renderChart();
            renderData();
            updateFilterStats();  // Ensure filter stats are updated after data loads
            updateProtectionChart();  // Update protection chart
        }
        
        function renderChart() {
            const chartContainer = document.getElementById('liquidationChart');
            
            // Используем отфильтрованные данные если они есть, иначе полные
            let softDataToUse = filteredSoftData || softData;
            let hardDataToUse = filteredHardData || hardData;
            
            // Если выбран конкретный диапазон дат через слайдеры, фильтруем данные по датам
            // чтобы график использовал те же данные, что и верхняя карточка
            if (selectedStartDate && selectedEndDate) {
                if (softDataToUse?.positions) {
                    const filteredPositions = softDataToUse.positions.filter(pos => {
                        if (!pos.first_dt) return false;
                        const openDate = new Date(pos.first_dt);
                        const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                        
                        // Позиция активна если пересекается с выбранным периодом
                        return openDate <= selectedEndDate && closeDate >= selectedStartDate;
                    });
                    
                    softDataToUse = {
                        ...softDataToUse,
                        positions: filteredPositions
                    };
                }
                
                if (hardDataToUse?.events) {
                    const filteredEvents = hardDataToUse.events.filter(event => {
                        if (!event.timestamp) return false;
                        const date = new Date(event.timestamp);
                        return date >= selectedStartDate && date <= selectedEndDate;
                    });
                    
                    hardDataToUse = {
                        ...hardDataToUse,
                        events: filteredEvents
                    };
                }
            }
            
            
            if (!softDataToUse || !hardDataToUse) {
                chartContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #666;">${t('noData')}</div>`;
                return;
            }
            
            // Определяем диапазон дат
            let startDate, endDate;
            
            // Находим минимальную и максимальную даты в ОТФИЛЬТРОВАННЫХ данных
            let minDate = new Date();
            let maxDate = new Date(0);
            
            if (softDataToUse.positions) {
                softDataToUse.positions.forEach(pos => {
                    if (pos.first_dt) {
                        const date = new Date(pos.first_dt);
                        if (date < minDate) minDate = date;
                        if (date > maxDate) maxDate = date;
                    }
                });
            }
            
            if (hardDataToUse.events) {
                hardDataToUse.events.forEach(event => {
                    if (event.timestamp) {
                        const date = new Date(event.timestamp);
                        if (date < minDate) minDate = date;
                        if (date > maxDate) maxDate = date;
                    }
                });
            }
            
            // Используем сохраненные даты если они есть
            if (selectedStartDate && selectedEndDate) {
                startDate = selectedStartDate;
                endDate = selectedEndDate;
            } else {
                // Если нет сохраненных дат, используем значения слайдеров
                const rangeStart = document.getElementById('rangeStart');
                const rangeEnd = document.getElementById('rangeEnd');
                const startDaysFromMin = parseInt(rangeStart.value) || 0;
                const endDaysFromMin = parseInt(rangeEnd.value) || 30;
                
                startDate = new Date(minDate.getTime() + startDaysFromMin * 24 * 60 * 60 * 1000);
                endDate = new Date(minDate.getTime() + endDaysFromMin * 24 * 60 * 60 * 1000);
            }
            
            // Если запрошенный диапазон больше доступных данных
            if (startDate < minDate) {
                startDate = minDate;
            }
            
            // Обновляем заголовок
            const title = document.getElementById('chartTitle');
            const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
            const startStr = startDate.toLocaleDateString(locale);
            const endStr = endDate.toLocaleDateString(locale);
            const dateRange = `${startStr} - ${endStr}`;
            title.textContent = `📈 ${t('chartByDays')} (${dateRange})`;
            
            // Подготавливаем данные по периодам
            const periodData = {};
            
            // Функция для получения ключа периода
            function getPeriodKey(date, period = chartPeriod) {
                if (period === 'day') {
                    return date.toISOString().split('T')[0];
                } else if (period === 'week') {
                    // Начало недели (понедельник)
                    const weekStart = new Date(date);
                    const day = weekStart.getDay();
                    const diff = weekStart.getDate() - day + (day === 0 ? -6 : 1);
                    weekStart.setDate(diff);
                    return weekStart.toISOString().split('T')[0];
                } else if (period === 'month') {
                    // Начало месяца
                    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-01`;
                }
            }
            
            // Инициализируем периоды
            let actualPeriod = chartPeriod; // Локальная переменная для этого вызова
            
            if (actualPeriod === 'day') {
                const totalDays = Math.ceil((endDate - startDate) / (24 * 60 * 60 * 1000)) + 1;
                
                // Инициализируем все дни
                for (let i = 0; i < totalDays; i++) {
                    const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);
                    const key = getPeriodKey(date, actualPeriod);
                    if (!periodData[key]) {
                        periodData[key] = { soft: 0, hard: 0, softTVL: 0, hardDebt: 0, date: date };
                    }
                }
            } else if (actualPeriod === 'week') {
                // Создаем периоды по неделям
                let currentDate = new Date(startDate);
                while (currentDate <= endDate) {
                    const key = getPeriodKey(currentDate, actualPeriod);
                    if (!periodData[key]) {
                        periodData[key] = { soft: 0, hard: 0, softTVL: 0, hardDebt: 0, date: new Date(key) };
                    }
                    currentDate.setDate(currentDate.getDate() + 7);
                }
            } else if (actualPeriod === 'month') {
                // Создаем периоды по месяцам
                let currentDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
                const endMonth = new Date(endDate.getFullYear(), endDate.getMonth(), 1);
                while (currentDate <= endMonth) {
                    const key = getPeriodKey(currentDate, actualPeriod);
                    if (!periodData[key]) {
                        periodData[key] = { soft: 0, hard: 0, softTVL: 0, hardDebt: 0, date: new Date(key) };
                    }
                    currentDate.setMonth(currentDate.getMonth() + 1);
                }
            }
            
            // Считаем софт ликвидации
            // Не используем предобработанные данные, так как они не учитывают фильтрацию по датам
            if (softDataToUse.positions) {
                // Обрабатываем все периоды одинаково
                softDataToUse.positions.forEach(pos => {
                    if (!pos.first_dt) return;
                    
                    const openDate = new Date(pos.first_dt);
                    const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                    const tvl = pos.cachedTVL || parseFloat(pos.tvl || pos.collateral_usd || 0);
                    
                    // Пропускаем позиции вне диапазона
                    if (closeDate < startDate || openDate > endDate) {
                        return;
                    }
                    
                    Object.keys(periodData).forEach(periodKey => {
                        const periodDate = new Date(periodKey);
                        let periodEnd;
                        
                        if (actualPeriod === 'week') {
                            periodEnd = new Date(periodDate);
                            periodEnd.setDate(periodEnd.getDate() + 7);
                        } else if (actualPeriod === 'month') {
                            periodEnd = new Date(periodDate.getFullYear(), periodDate.getMonth() + 1, 1);
                        } else { // day
                            periodEnd = new Date(periodDate);
                            periodEnd.setDate(periodEnd.getDate() + 1);
                        }
                        
                        // Позиция активна если была открыта до конца периода И закрыта после начала периода
                        if (openDate < periodEnd && closeDate >= periodDate) {
                            periodData[periodKey].soft++;
                            periodData[periodKey].softTVL += tvl;
                        }
                    });
                });
            }
            
            
            // Считаем хард ликвидации
            if (hardDataToUse.events) {
                // Всегда используем прямой подсчет для корректной работы с фильтрами
                hardDataToUse.events.forEach(event => {
                    if (event.timestamp) {
                        const date = new Date(event.timestamp);
                        if (date >= startDate && date <= endDate) {
                            const key = getPeriodKey(date, actualPeriod);
                            if (periodData[key]) {
                                periodData[key].hard++;
                                periodData[key].hardDebt += event.cachedDebt || parseFloat(event.debt_with_discount || event.debt || 0);
                            }
                        }
                    }
                });
            }
            
            // Находим максимальные значения в зависимости от режима
            let maxSoft = 0;
            let maxHard = 0;
            let totalChartSoftTVL = 0;
            let totalChartHardDebt = 0;
            let maxPeriodSoftTVL = 0;
            let maxPeriodHardDebt = 0;
            Object.values(periodData).forEach(period => {
                if (chartMode === 'sum') {
                    maxSoft = Math.max(maxSoft, period.softTVL);
                    maxHard = Math.max(maxHard, period.hardDebt);
                    // Для отладки: находим максимальные значения одного периода
                    maxPeriodSoftTVL = Math.max(maxPeriodSoftTVL, period.softTVL);
                    maxPeriodHardDebt = Math.max(maxPeriodHardDebt, period.hardDebt);
                    // И суммируем все хард долги (они не пересекаются)
                    totalChartHardDebt += period.hardDebt;
                } else {
                    maxSoft = Math.max(maxSoft, period.soft);
                    maxHard = Math.max(maxHard, period.hard);
                }
            });
            
            const maxValue = Math.max(maxSoft, maxHard);
            
            // Рисуем диаграмму
            let html = '';
            
            // Добавляем легенду в верхний правый угол графика
            html += `
                <div style="position: absolute; top: 5px; right: 5px; background: rgba(255,255,255,0.9); padding: 8px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); z-index: 10; font-size: 12px;">
                    <div style="display: flex; align-items: center; margin-bottom: 4px;">
                        <div style="width: 12px; height: 12px; background: rgba(76, 175, 80, 0.8); border-radius: 2px; margin-right: 6px;"></div>
                        <span>${t('softLiquidations')}</span>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <div style="width: 12px; height: 12px; background: rgba(255, 107, 107, 0.9); border-radius: 2px; margin-right: 6px;"></div>
                        <span>${t('hardLiquidations')}</span>
                    </div>
                </div>
            `;
            
            // Добавляем Y-ось (вертикальную шкалу)
            html += '<div class="chart-y-axis">';
            const ySteps = 5; // Количество делений на Y-оси
            for (let i = 0; i <= ySteps; i++) {
                const value = (maxValue * i) / ySteps;
                let label;
                if (chartMode === 'sum') {
                    // Форматируем сумму в доллары
                    if (value >= 1000000) {
                        label = `$${(value / 1000000).toFixed(1)}M`;
                    } else if (value >= 1000) {
                        label = `$${(value / 1000).toFixed(0)}K`;
                    } else {
                        label = `$${value.toFixed(0)}`;
                    }
                } else {
                    // Для количества просто число
                    label = value.toFixed(0);
                }
                html += `<div class="chart-y-label">${label}</div>`;
            }
            html += '</div>';
            
            // Добавляем контейнер для баров с отступом слева для Y-оси
            html += '<div style="position: absolute; left: 50px; right: 0; top: 0; bottom: 30px;">';
            
            const dates = Object.keys(periodData).sort();
            const barWidth = Math.min(100 / dates.length, actualPeriod === 'month' ? 8 : actualPeriod === 'week' ? 4 : 2);
            
            dates.forEach((dateStr, index) => {
                const period = periodData[dateStr];
                let softValue, hardValue;
                
                if (chartMode === 'sum') {
                    softValue = period.softTVL;
                    hardValue = period.hardDebt;
                } else {
                    softValue = period.soft;
                    hardValue = period.hard;
                }
                
                // Уменьшаем максимальную высоту для мобильных устройств
                const chartHeight = window.innerWidth <= 768 ? 150 : 200;
                const softHeight = maxValue > 0 ? (softValue / maxValue * chartHeight) : 0;
                let hardHeight = maxValue > 0 ? (hardValue / maxValue * chartHeight) : 0;
                
                // Минимальная высота 1px для хард событий, чтобы они были видны
                if (hardValue > 0 && hardHeight < 1) {
                    hardHeight = 1;
                }
                
                // Определяем порядок столбиков - меньший сзади, больший спереди
                let barsHtml = '';
                if (hardValue > softValue) {
                    // Если хард больше - сначала рисуем хард (сзади), потом софт (спереди)
                    barsHtml = `
                        <div class="bar-hard" style="height: ${hardHeight}px; z-index: 1;"></div>
                        <div class="bar-soft" style="height: ${softHeight}px; z-index: 2;"></div>
                    `;
                } else {
                    // Если софт больше или равен - сначала рисуем софт (сзади), потом хард (спереди)
                    barsHtml = `
                        <div class="bar-soft" style="height: ${softHeight}px; z-index: 1;"></div>
                        <div class="bar-hard" style="height: ${hardHeight}px; z-index: 2;"></div>
                    `;
                }
                
                html += `
                    <div class="chart-bar" style="left: ${index * barWidth}%; width: ${barWidth}%;" 
                         onmouseover="showChartTooltip(event, '${dateStr}', ${period.soft}, ${period.hard}, ${period.softTVL}, ${period.hardDebt})"
                         onmouseout="hideChartTooltip()">
                        ${barsHtml}
                    </div>
                `;
            });
            
            // Закрываем контейнер для баров
            html += '</div>';
            
            // Добавляем ось X с правильными метками для разных периодов
            html += '<div class="chart-axis">';
            
            // Определяем интервал меток в зависимости от периода
            let labelInterval;
            if (actualPeriod === 'month') {
                labelInterval = Math.max(1, Math.floor(dates.length / 12));
            } else if (actualPeriod === 'week') {
                labelInterval = Math.max(1, Math.floor(dates.length / 8));
            } else {
                labelInterval = Math.max(1, Math.floor(dates.length / 6));
            }
            
            for (let i = 0; i < dates.length; i += labelInterval) {
                if (dates[i]) {
                    const date = new Date(dates[i]);
                    let label;
                    
                    if (actualPeriod === 'month') {
                        // Для месяцев показываем "MM/YY"
                        const month = (date.getMonth() + 1).toString().padStart(2, '0');
                        const year = date.getFullYear().toString().slice(-2);
                        label = `${month}/${year}`;
                    } else if (actualPeriod === 'week') {
                        // Для недель показываем "DD.MM" (начало недели)
                        label = `${date.getDate()}.${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    } else {
                        // Для дней показываем "DD.MM"
                        label = `${date.getDate()}.${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    }
                    
                    html += `<span>${label}</span>`;
                }
            }
            html += '</div>';
            
            chartContainer.innerHTML = html;
        }
        
        function showChartTooltip(event, dateStr, soft, hard, softTVL, hardDebt) {
            const tooltip = document.getElementById('chartTooltip');
            const startDate = new Date(dateStr);
            const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
            
            let dateDisplay;
            if (chartPeriod === 'week') {
                // For week, show range from Monday to Sunday
                const endDate = new Date(startDate);
                endDate.setDate(startDate.getDate() + 6);
                const startStr = startDate.toLocaleDateString(locale, { day: 'numeric', month: 'short' });
                const endStr = endDate.toLocaleDateString(locale, { day: 'numeric', month: 'short', year: 'numeric' });
                dateDisplay = `${startStr} - ${endStr}`;
            } else if (chartPeriod === 'month') {
                // For month, show month and year
                const monthYear = startDate.toLocaleDateString(locale, { month: 'long', year: 'numeric' });
                const lastDay = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0).getDate();
                const startStr = `1`;
                const endStr = `${lastDay} ${monthYear}`;
                dateDisplay = `${startStr} - ${endStr}`;
            } else {
                // For day, show single date with same format as others
                dateDisplay = startDate.toLocaleDateString(locale, { day: 'numeric', month: 'short', year: 'numeric' });
            }
            
            // Calculate protected amount
            const protectedAmount = softTVL - hardDebt;
            const protectedPercent = softTVL > 0 ? (protectedAmount / softTVL * 100) : 0;
            const protectedLabel = currentLang === 'ru' ? 'Защищено' : 'Protected';
            
            
            tooltip.innerHTML = `
                <strong>${dateDisplay}</strong><br>
                💧 ${currentLang === 'ru' ? 'Мягких' : 'Soft'}: $${formatNumber(softTVL)} (${soft} ${currentLang === 'ru' ? 'поз.' : 'pos.'})<br>
                🔥 ${currentLang === 'ru' ? 'Жёстких' : 'Hard'}: $${formatNumber(hardDebt)} (${hard} ${currentLang === 'ru' ? 'соб.' : 'events'})<br>
                🛡️ ${protectedLabel}: $${formatNumber(Math.abs(protectedAmount))} (${protectedPercent.toFixed(1)}%) ${protectedAmount >= 0 ? '✅' : '⚠️'}
            `;
            
            tooltip.style.display = 'block';
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY - 40 + 'px';
        }
        
        function hideChartTooltip() {
            document.getElementById('chartTooltip').style.display = 'none';
        }

        function renderStats() {
            const statsGrid = document.getElementById('statsGrid');
            
            if (!softData && !hardData) {
                statsGrid.innerHTML = `<div class="loading">${t('noData')}</div>`;
                return;
            }

            let html = '';
            
            // Используем отфильтрованные данные если они есть, иначе оригинальные
            const softToUse = filteredSoftData || softData;
            const hardToUse = filteredHardData || hardData;
            
            // Определяем, нужно ли пересчитывать или использовать готовые суммы
            let softTVL = 0;
            let hardDebtWithDiscount = 0;
            
            // Проверяем, применены ли фильтры
            const hasFilters = (tableDateStart || tableDateEnd || 
                               (filteredSoftData && filteredSoftData.positions?.length !== softData?.positions?.length) ||
                               (filteredHardData && filteredHardData.events?.length !== hardData?.events?.length));
            
            if (hasFilters) {
                // Пересчитываем TVL для soft с учетом всех фильтров
                if (softToUse?.positions) {
                    let positions = softToUse.positions;
                    if (tableDateStart || tableDateEnd) {
                        positions = positions.filter(pos => {
                            if (!pos.first_dt) return false;
                            const openDate = new Date(pos.first_dt);
                            const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                            
                            // Position is active if it overlaps with the date range
                            const rangeEnd = tableDateEnd || new Date();
                            const rangeStart = tableDateStart || new Date(0);
                            
                            return openDate <= rangeEnd && closeDate >= rangeStart;
                        });
                    }
                    softTVL = positions.reduce((sum, pos) => sum + parseFloat(pos.tvl || pos.collateral_usd || 0), 0);
                }
                
                // Пересчитываем debt для hard с учетом всех фильтров
                if (hardToUse?.events) {
                    let events = hardToUse.events;
                    if (tableDateStart || tableDateEnd) {
                        events = events.filter(event => {
                            if (!event.timestamp) return false;
                            const date = new Date(event.timestamp);
                            if (tableDateStart && date < tableDateStart) return false;
                            if (tableDateEnd && date > tableDateEnd) return false;
                            return true;
                        });
                    }
                    events.forEach(event => {
                        // Используем готовое значение debt_with_discount из JSON
                        hardDebtWithDiscount += parseFloat(event.debt_with_discount || event.debt || 0);
                    });
                }
            } else {
                // Используем готовые суммы из summary/total когда нет фильтров
                softTVL = softData?.summary?.total_tvl || 0;
                hardDebtWithDiscount = hardData?.total?.debt_with_discount || 0;
                
                // Отладочный вывод
            }
            
            const protectedAmount = softTVL - hardDebtWithDiscount;
            const protectionPercent = softTVL > 0 ? (protectedAmount / softTVL * 100) : 0;
            
            
            // ГЛАВНЫЙ БЛОК - Защищено депозитов с диаграммой (занимает 2 колонки)
            if (softData && hardData) {
                const isPositive = protectedAmount > 0;
                html += `
                    <div class="stat-card protection ${!isPositive ? 'negative' : ''}" style="position: relative;">
                        <span onclick="showMethodologyPopup()" style="position: absolute; top: 15px; right: 15px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; color: rgba(255,255,255,0.8); border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; width: 28px; height: 28px; line-height: 1; font-weight: bold; transition: all 0.3s; z-index: 10; background: rgba(255,255,255,0.1);" onmouseover="this.style.color='white'; this.style.borderColor='white'; this.style.transform='scale(1.1)'; this.style.background='rgba(255,255,255,0.2)';" onmouseout="this.style.color='rgba(255,255,255,0.8)'; this.style.borderColor='rgba(255,255,255,0.4)'; this.style.transform='scale(1)'; this.style.background='rgba(255,255,255,0.1)';" title="${currentLang === 'en' ? 'Methodology' : 'Методология'}">?</span>
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 30px;">
                            <div style="flex: 1; text-align: left;">
                                <div class="stat-label">
                                    ${t('protectedFromLiquidation')}
                                </div>
                                <div class="stat-value">$${formatNumber(Math.abs(protectedAmount))}</div>
                                <div class="protection-percent">
                                    <span>${isPositive ? '✅' : '⚠️'} ${protectionPercent.toFixed(1)}% ${t('ofTVLInSoft').split('<br>')[0]}</span>
                                    <span style="display: block; font-size: 0.9em; opacity: 0.8;">${t('ofTVLInSoft').split('<br>')[1] || ''}</span>
                                </div>
                            </div>
                            <div style="position: relative; width: 180px; height: 180px;">
                                <canvas id="protectionChartInline" width="180" height="180" style="display: block;"></canvas>
                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                                    <div style="font-size: 28px; font-weight: 600; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">${protectionPercent.toFixed(0)}%</div>
                                    <div style="font-size: 12px; color: rgba(255,255,255,0.9); text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">${t('protected')}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Prepare network and token options based on current filter state
            let networkOptions = `<option value="">${t('allNetworks')}</option>`;
            let tokenOptions = `<option value="">${t('allTokens')}</option>`;
            
            // Get current filtered available options based on platform filter
            const currentPlatform = window.savedFilterValues ? window.savedFilterValues.platform : '';
            let filteredNetworks = new Set();
            let tokenTVLMap = new Map(); // Map to store token -> TVL
            
            // Collect available networks and calculate TVL for each token based on platform filter
            if (softData && softData.positions) {
                softData.positions.forEach(pos => {
                    if (!currentPlatform || pos.platform === currentPlatform) {
                        if (pos.chain) filteredNetworks.add(pos.chain);
                        if (pos.collateral_token) {
                            const tvl = parseFloat(pos.tvl || pos.collateral_usd || 0);
                            const currentTVL = tokenTVLMap.get(pos.collateral_token) || 0;
                            tokenTVLMap.set(pos.collateral_token, currentTVL + tvl);
                        }
                    }
                });
            }
            if (hardData && hardData.events) {
                hardData.events.forEach(event => {
                    if (!currentPlatform || event.platform === currentPlatform) {
                        if (event.chain) filteredNetworks.add(event.chain);
                        if (event.collateral_token) {
                            const tvl = parseFloat(event.collateral_usd || 0);
                            const currentTVL = tokenTVLMap.get(event.collateral_token) || 0;
                            tokenTVLMap.set(event.collateral_token, currentTVL + tvl);
                        }
                    }
                });
            }
            
            // Build network options
            Array.from(filteredNetworks).sort().forEach(network => {
                const selected = window.savedFilterValues && window.savedFilterValues.network === network ? 'selected' : '';
                networkOptions += `<option value="${network}" ${selected}>${network}</option>`;
            });
            
            // Sort tokens by TVL (descending) and build options
            const sortedTokens = Array.from(tokenTVLMap.entries())
                .sort((a, b) => b[1] - a[1]) // Sort by TVL descending
                .map(([token, tvl]) => token);
            
            sortedTokens.forEach(token => {
                const selected = window.savedFilterValues && window.savedFilterValues.token === token ? 'selected' : '';
                tokenOptions += `<option value="${token}" ${selected}>${token}</option>`;
            });
            
            // Get saved values
            const savedPlatform = window.savedFilterValues ? window.savedFilterValues.platform : '';
            const savedAddress = window.savedFilterValues ? window.savedFilterValues.address : '';
            
            // Add filters as 2nd card with modern gradient background
            html += `
                <div class="stat-card" style="display: flex; flex-direction: column; gap: 7px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 14px; position: relative; overflow: hidden;">
                    <!-- Decorative background pattern -->
                    <div style="position: absolute; top: -50px; right: -50px; width: 150px; height: 150px; background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); border-radius: 50%;"></div>
                    <div style="position: absolute; bottom: -30px; left: -30px; width: 100px; height: 100px; background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%); border-radius: 50%;"></div>
                    
                    <!-- Filter header -->
                    <div style="margin-bottom: 4px; position: relative; z-index: 1;">
                        <div style="font-size: 13px; font-weight: 600; color: white; text-transform: uppercase; letter-spacing: 1.5px; display: flex; align-items: center; gap: 6px;">
                            <span style="background: rgba(255,255,255,0.2); padding: 3px 5px; border-radius: 5px; font-size: 11px;">🔍</span>
                            <span>${t('filters')}</span>
                        </div>
                    </div>
                    
                    <!-- Platform filter -->
                    <select id="platformFilter" onchange="applyFilters()" class="modern-select" style="width: 100%; padding: 7px 9px; font-size: 12px; border: 2px solid rgba(255,255,255,0.3); border-radius: 7px; background: rgba(255,255,255,0.95); color: #333; font-weight: 500; transition: all 0.3s; cursor: pointer; position: relative; z-index: 1;">
                        <option value="" ${savedPlatform === '' ? 'selected' : ''}>${t('allPlatforms')}</option>
                        <option value="LlamaLend" ${savedPlatform === 'LlamaLend' ? 'selected' : ''}>🦙 LlamaLend</option>
                        <option value="crvUSD" ${savedPlatform === 'crvUSD' ? 'selected' : ''}>💱 crvUSD</option>
                    </select>
                    
                    <!-- Network filter -->
                    <select id="networkFilter" onchange="applyFilters()" class="modern-select" style="width: 100%; padding: 7px 9px; font-size: 12px; border: 2px solid rgba(255,255,255,0.3); border-radius: 7px; background: rgba(255,255,255,0.95); color: #333; font-weight: 500; transition: all 0.3s; cursor: pointer; position: relative; z-index: 1;">
                        ${networkOptions}
                    </select>
                    
                    <!-- Token filter -->
                    <select id="tokenFilter" onchange="applyFilters()" class="modern-select" style="width: 100%; padding: 7px 9px; font-size: 12px; border: 2px solid rgba(255,255,255,0.3); border-radius: 7px; background: rgba(255,255,255,0.95); color: #333; font-weight: 500; transition: all 0.3s; cursor: pointer; position: relative; z-index: 1;">
                        ${tokenOptions}
                    </select>
                    
                    <!-- Address filter -->
                    <input type="text" id="addressFilter" placeholder="${t('addressPlaceholder')}" value="${savedAddress}" onkeyup="if(event.key === 'Enter') applyFilters()" style="width: 100%; padding: 7px 9px; font-size: 12px; border: 2px solid rgba(255,255,255,0.3); border-radius: 7px; background: rgba(255,255,255,0.95); color: #333; font-weight: 500; transition: all 0.3s; position: relative; z-index: 1;" onfocus="this.style.borderColor='rgba(255,255,255,0.6)'; this.style.background='white';" onblur="this.style.borderColor='rgba(255,255,255,0.3)'; this.style.background='rgba(255,255,255,0.95)';">
                    
                    <!-- Buttons -->
                    <div style="display: flex; gap: 7px; margin-top: 3px; position: relative; z-index: 1;">
                        <button onclick="applyFilters()" style="flex: 1; padding: 7px; font-size: 12px; background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; border: none; border-radius: 7px; cursor: pointer; font-weight: 600; transition: all 0.3s; box-shadow: 0 3px 12px rgba(76, 175, 80, 0.3); text-transform: uppercase; letter-spacing: 0.5px;" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 15px rgba(76, 175, 80, 0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 12px rgba(76, 175, 80, 0.3)';">
                            ✓ ${t('apply')}
                        </button>
                        <button onclick="resetFilters()" style="flex: 1; padding: 7px; font-size: 12px; background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 7px; cursor: pointer; font-weight: 600; transition: all 0.3s; text-transform: uppercase; letter-spacing: 0.5px;" onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='translateY(-1px)';" onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='translateY(0)';">
                            ↺ ${t('resetFilters').replace('Filters', '')}
                        </button>
                    </div>
                </div>
            `;

            // Софт ликвидации - расширенная информация
            if (softToUse) {
                let totalPositions = 0;
                let totalTVL = 0;
                let totalDebt = 0;
                let llamaLendCount = 0;
                let crvusdCount = 0;
                
                if (hasFilters) {
                    // Пересчитываем статистику для отфильтрованных данных
                    if (softToUse.positions) {
                        // Фильтруем по датам если нужно
                        let positions = softToUse.positions;
                        if (tableDateStart || tableDateEnd) {
                            positions = positions.filter(pos => {
                                if (!pos.first_dt) return false;
                                const openDate = new Date(pos.first_dt);
                                const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                                
                                // Position is active if it overlaps with the date range
                                const rangeEnd = tableDateEnd || new Date();
                                const rangeStart = tableDateStart || new Date(0);
                                
                                return openDate <= rangeEnd && closeDate >= rangeStart;
                            });
                        }
                        
                        // Считаем статистику
                        positions.forEach(pos => {
                            totalPositions++;
                            totalTVL += parseFloat(pos.tvl || pos.collateral_usd || 0);
                            totalDebt += parseFloat(pos.debt || 0);
                            
                            if (pos.platform === 'LlamaLend') {
                                llamaLendCount++;
                            } else if (pos.platform === 'crvUSD') {
                                crvusdCount++;
                            }
                        });
                    }
                } else {
                    // Используем готовые данные из summary когда нет фильтров
                    const summary = softData?.summary || {};
                    totalPositions = summary.total_positions || 0;
                    totalTVL = summary.total_tvl || 0;
                    totalDebt = summary.total_debt || 0;
                    llamaLendCount = summary.llamalend_positions || 0;
                    crvusdCount = summary.crvusd_positions || 0;
                }
                
                // Подсчет позиций по пользователям (учитывая все рынки)
                const userPositionsCount = new Map();
                if (softToUse?.positions) {
                    let positions = softToUse.positions;
                    if (tableDateStart || tableDateEnd) {
                        positions = positions.filter(pos => {
                            if (!pos.first_dt) return false;
                            const openDate = new Date(pos.first_dt);
                            const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                            
                            // Position is active if it overlaps with the date range
                            const rangeEnd = tableDateEnd || new Date();
                            const rangeStart = tableDateStart || new Date(0);
                            
                            return openDate <= rangeEnd && closeDate >= rangeStart;
                        });
                    }
                    positions.forEach(pos => {
                        if (pos.user) {
                            // Каждая запись в positions - это отдельная позиция/сегмент
                            const currentCount = userPositionsCount.get(pos.user) || 0;
                            userPositionsCount.set(pos.user, currentCount + 1);
                        }
                    });
                }
                
                const uniqueUsersCount = userPositionsCount.size;
                const avgPositionSize = totalPositions > 0 ? (totalTVL / totalPositions) : 0;
                const avgPositionsPerUser = uniqueUsersCount > 0 ? (totalPositions / uniqueUsersCount) : 0;
                
                html += `
                    <div class="stat-card">
                        <div class="stat-label">${t('softLiquidationsLabel')}</div>
                        <div class="stat-value">$${formatNumber(totalTVL)}</div>
                        <div style="font-size: 14px; margin-top: 8px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">${t('positionsLabel')}:</span>
                                <strong>${totalPositions}</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">${t('totalDebt')}:</span>
                                <strong>$${formatNumber(totalDebt)}</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">${t('positionsPerUser') || 'Positions per user'}:</span>
                                <strong>${avgPositionsPerUser.toFixed(2)}</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">${t('averagePosition')}:</span>
                                <strong>$${formatNumber(avgPositionSize)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Хард ликвидации - расширенная информация  
            if (hardToUse) {
                let totalCount = 0;
                let totalDebt = 0;
                let totalDebtWithDiscount = 0;
                let lendingCount = 0;
                let crvusdCount = 0;
                
                if (hasFilters) {
                    // Пересчитываем статистику для отфильтрованных данных
                    if (hardToUse.events) {
                        // Фильтруем по датам если нужно
                        let events = hardToUse.events;
                        if (tableDateStart || tableDateEnd) {
                            events = events.filter(event => {
                                if (!event.timestamp) return false;
                                const date = new Date(event.timestamp);
                                if (tableDateStart && date < tableDateStart) return false;
                                if (tableDateEnd && date > tableDateEnd) return false;
                                return true;
                            });
                        }
                        
                        // Считаем статистику
                        events.forEach(event => {
                            totalCount++;
                            const debt = parseFloat(event.debt || 0);
                            totalDebt += debt;
                            // Используем готовое значение debt_with_discount из JSON
                            totalDebtWithDiscount += parseFloat(event.debt_with_discount || event.debt || 0);
                            
                            if (event.platform === 'LlamaLend') {
                                lendingCount++;
                            } else if (event.platform === 'crvUSD') {
                                crvusdCount++;
                            }
                        });
                    }
                } else {
                    // Используем готовые данные из total когда нет фильтров
                    const total = hardData?.total || {};
                    totalCount = total.count || 0;
                    totalDebt = total.debt || 0;
                    totalDebtWithDiscount = total.debt_with_discount || 0;
                    
                    // Подсчет по платформам
                    if (hardData?.events) {
                        hardData.events.forEach(e => {
                            if (e.platform === 'LlamaLend') lendingCount++;
                            else if (e.platform === 'crvUSD') crvusdCount++;
                        });
                    }
                }
                
                // Подсчет уникальных пользователей для хард ликвидаций
                const uniqueHardUsers = new Set();
                if (hardToUse?.events) {
                    let events = hardToUse.events;
                    if (tableDateStart || tableDateEnd) {
                        events = events.filter(event => {
                            if (!event.timestamp) return false;
                            const date = new Date(event.timestamp);
                            if (tableDateStart && date < tableDateStart) return false;
                            if (tableDateEnd && date > tableDateEnd) return false;
                            return true;
                        });
                    }
                    events.forEach(event => {
                        if (event.user) uniqueHardUsers.add(event.user);
                    });
                }
                
                const uniqueHardUsersCount = uniqueHardUsers.size;
                const avgLiquidationsPerUser = uniqueHardUsersCount > 0 ? (totalCount / uniqueHardUsersCount) : 0;
                const avgDiscount = totalDebt > 0 ? 
                    ((totalDebt - totalDebtWithDiscount) / totalDebt * 100) : 0;
                const avgLiquidationSize = totalCount > 0 ? 
                    (totalDebt / totalCount) : 0;
                
                html += `
                    <div class="stat-card">
                        <div class="stat-label">${t('hardLiquidationsLabel')}</div>
                        <div class="stat-value">$${formatNumber(totalDebtWithDiscount)}</div>
                        <div style="font-size: 14px; margin-top: 8px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">${t('events')}:</span>
                                <strong>${totalCount}</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">${t('debtWithoutDiscount')}:</span>
                                <strong>$${formatNumber(totalDebt)}</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">${t('averageDiscount')}:</span>
                                <strong style="color: #f44336">${avgDiscount.toFixed(1)}%</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">${t('averageSize')}:</span>
                                <strong>$${formatNumber(avgLiquidationSize)}</strong>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Статистика по платформам - объединенная
            if (softToUse) {
                let llamalendPositions = 0;
                let llamalendTVL = 0;
                let llamalendDebt = 0;
                let crvusdPositions = 0;
                let crvusdTVL = 0;
                let crvusdDebt = 0;
                
                if (hasFilters) {
                    // Пересчитываем статистику по платформам для отфильтрованных данных
                    if (softToUse.positions) {
                        // Фильтруем по датам если нужно
                        let positions = softToUse.positions;
                        if (tableDateStart || tableDateEnd) {
                            positions = positions.filter(pos => {
                                if (!pos.first_dt) return false;
                                const openDate = new Date(pos.first_dt);
                                const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                                
                                // Position is active if it overlaps with the date range
                                const rangeEnd = tableDateEnd || new Date();
                                const rangeStart = tableDateStart || new Date(0);
                                
                                return openDate <= rangeEnd && closeDate >= rangeStart;
                            });
                        }
                        
                        // Считаем статистику по платформам
                        positions.forEach(pos => {
                            const tvl = parseFloat(pos.tvl || pos.collateral_usd || 0);
                            const debt = parseFloat(pos.debt || 0);
                            
                            if (pos.platform === 'LlamaLend') {
                                llamalendPositions++;
                                llamalendTVL += tvl;
                                llamalendDebt += debt;
                            } else if (pos.platform === 'crvUSD') {
                                crvusdPositions++;
                                crvusdTVL += tvl;
                                crvusdDebt += debt;
                            }
                        });
                    }
                } else {
                    // Используем готовые данные из summary когда нет фильтров
                    const summary = softData?.summary || {};
                    llamalendPositions = summary.llamalend_positions || 0;
                    llamalendTVL = summary.llamalend_tvl || 0;
                    llamalendDebt = summary.llamalend_debt || 0;
                    crvusdPositions = summary.crvusd_positions || 0;
                    crvusdTVL = summary.crvusd_tvl || 0;
                    crvusdDebt = summary.crvusd_debt || 0;
                }
            }

            statsGrid.innerHTML = html;
        }

        function renderData() {
            const dataTable = document.getElementById('dataTable');
            
            // Update distribution charts only if we have data
            if (filteredSoftData || filteredHardData || softData || hardData) {
                updateDistributionCharts();
            }
            
            if (currentTab === 'soft') {
                renderSoftLiquidations(dataTable);
            } else if (currentTab === 'hard') {
                renderHardLiquidations(dataTable);
            } else if (currentTab === 'comparison') {
                renderComparison(dataTable);
            }
        }

        function renderSoftLiquidations(container) {
            // Add tab buttons at the top
            let html = `
                <div style="display: flex; gap: 0; margin-bottom: 20px; align-items: center; justify-content: flex-end;">
                    <div style="display: inline-flex; gap: 2px; background: #f8f9fa; padding: 4px; border-radius: 6px;">
                        <button class="tab ${currentTab === 'soft' ? 'active' : ''}" onclick="window.switchTab('soft')" style="padding: 8px 16px;">
                            💧 ${t('softLiquidations')}
                        </button>
                        <button class="tab ${currentTab === 'hard' ? 'active' : ''}" onclick="window.switchTab('hard')" style="padding: 8px 16px;">
                            🔥 ${t('hardLiquidations')}
                        </button>
                        <button class="tab ${currentTab === 'comparison' ? 'active' : ''}" onclick="window.switchTab('comparison')" style="padding: 8px 16px;">
                            📊 ${t('comparison')}
                        </button>
                    </div>
                </div>
            `;
            
            if (!filteredSoftData || !filteredSoftData.positions) {
                container.innerHTML = html + `<div class="no-data">${t('noData')}</div>`;
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            let positions = [...filteredSoftData.positions];
            
            // Фильтрация по датам если указаны
            if (tableDateStart || tableDateEnd) {
                positions = positions.filter(pos => {
                    if (!pos.first_dt) return false;
                    const date = new Date(pos.first_dt);
                    if (tableDateStart && date < tableDateStart) return false;
                    if (tableDateEnd && date > tableDateEnd) return false;
                    return true;
                });
            }
            if (positions.length === 0) {
                container.innerHTML = html + `<div class="no-data">${t('noPositionsMatchingFilters')}</div>`;
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            // Сортировка
            positions.sort((a, b) => {
                let aVal, bVal;
                
                switch(sortColumn) {
                    case 'first_dt':
                        aVal = a[sortColumn] ? new Date(a[sortColumn]).getTime() : 0;
                        bVal = b[sortColumn] ? new Date(b[sortColumn]).getTime() : 0;
                        break;
                    case 'tvl':
                        aVal = a[sortColumn] || 0;
                        bVal = b[sortColumn] || 0;
                        break;
                    case 'market_name':
                    case 'platform':
                    case 'chain':
                    case 'user':
                    case 'collateral_token':
                        aVal = (a[sortColumn] || '').toLowerCase();
                        bVal = (b[sortColumn] || '').toLowerCase();
                        break;
                    default:
                        aVal = a[sortColumn];
                        bVal = b[sortColumn];
                }
                
                if (sortDirection === 'asc') {
                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                    return bVal > aVal ? 1 : bVal < aVal ? -1 : 0;
                }
            });
            
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = positions.slice(start, end);

            html += `
                <div class="table-wrapper">
                    <div class="table-header">
                        <h2 style="margin: 0;">💧 ${t('softLiquidationsInPositions')}</h2>
                    </div>
                <div class="table-scroll-indicator" id="scrollHintSoft">← ${t('swipeToScroll')} →</div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable('first_dt')">
                                ${t('date')} ${getSortArrow('first_dt')}
                            </th>
                            <th class="sortable" onclick="sortTable('platform')">
                                ${t('platform')} ${getSortArrow('platform')}
                            </th>
                            <th class="sortable" onclick="sortTable('market_name')">
                                ${t('market')} ${getSortArrow('market_name')}
                            </th>
                            <th class="sortable" onclick="sortTable('chain')">
                                ${t('network')} ${getSortArrow('chain')}
                            </th>
                            <th class="sortable" onclick="sortTable('user')">
                                ${t('user')} ${getSortArrow('user')}
                            </th>
                            <th class="sortable" onclick="sortTable('collateral_token')">
                                ${t('token')} ${getSortArrow('collateral_token')}
                            </th>
                            <th class="sortable" onclick="sortTable('tvl')">
                                ${t('maxTVL')} ${getSortArrow('tvl')}
                            </th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            pageData.forEach(pos => {
                const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
                const dateOnly = pos.first_dt ? new Date(pos.first_dt).toLocaleDateString(locale) : 'N/A';
                
                // Определяем базовый URL для адресов в зависимости от сети
                let addressBaseUrl = '';
                switch(pos.chain) {
                    case 'ETHEREUM':
                        addressBaseUrl = 'https://etherscan.io/address/';
                        break;
                    case 'ARBITRUM':
                        addressBaseUrl = 'https://arbiscan.io/address/';
                        break;
                    case 'OPTIMISM':
                        addressBaseUrl = 'https://optimistic.etherscan.io/address/';
                        break;
                    case 'POLYGON':
                        addressBaseUrl = 'https://polygonscan.com/address/';
                        break;
                    case 'GNOSIS':
                        addressBaseUrl = 'https://gnosisscan.io/address/';
                        break;
                    case 'BASE':
                        addressBaseUrl = 'https://basescan.org/address/';
                        break;
                    case 'FRAXTAL':
                        addressBaseUrl = 'https://fraxscan.com/address/';
                        break;
                    default:
                        addressBaseUrl = 'https://etherscan.io/address/';
                }
                
                const userDisplay = pos.user ? 
                    `<a href="${addressBaseUrl}${pos.user}" target="_blank" title="${pos.user}" class="explorer-link">${formatAddress(pos.user)}</a>` : 
                    'N/A';
                
                html += `
                    <tr>
                        <td>${dateOnly}</td>
                        <td>${pos.platform || 'N/A'}</td>
                        <td>${pos.market_name || 'N/A'}</td>
                        <td>${pos.chain || 'N/A'}</td>
                        <td>${userDisplay}</td>
                        <td>${pos.collateral_token || 'N/A'}</td>
                        <td>$${formatNumber(pos.tvl || 0)}</td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
            
            // Check if table needs scrolling on mobile
            setTimeout(() => {
                const table = container.querySelector('table');
                const indicator = document.getElementById('scrollHintSoft');
                if (table && indicator && window.innerWidth <= 768) {
                    if (table.scrollWidth > table.clientWidth) {
                        indicator.style.display = 'block';
                    } else {
                        indicator.style.display = 'none';
                    }
                }
            }, 100);
            
            renderPagination(positions.length);
        }

        function renderHardLiquidations(container) {
            // Add tab buttons at the top
            let html = `
                <div style="display: flex; gap: 0; margin-bottom: 20px; align-items: center; justify-content: flex-end;">
                    <div style="display: inline-flex; gap: 2px; background: #f8f9fa; padding: 4px; border-radius: 6px;">
                        <button class="tab ${currentTab === 'soft' ? 'active' : ''}" onclick="window.switchTab('soft')" style="padding: 8px 16px;">
                            💧 ${t('softLiquidations')}
                        </button>
                        <button class="tab ${currentTab === 'hard' ? 'active' : ''}" onclick="window.switchTab('hard')" style="padding: 8px 16px;">
                            🔥 ${t('hardLiquidations')}
                        </button>
                        <button class="tab ${currentTab === 'comparison' ? 'active' : ''}" onclick="window.switchTab('comparison')" style="padding: 8px 16px;">
                            📊 ${t('comparison')}
                        </button>
                    </div>
                </div>
            `;
            
            if (!filteredHardData || !filteredHardData.events) {
                container.innerHTML = html + `<div class="no-data">${t('noData')}</div>`;
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            let events = [...filteredHardData.events];
            
            // Фильтрация по датам если указаны
            if (tableDateStart || tableDateEnd) {
                events = events.filter(event => {
                    if (!event.timestamp) return false;
                    const date = new Date(event.timestamp);
                    if (tableDateStart && date < tableDateStart) return false;
                    if (tableDateEnd && date > tableDateEnd) return false;
                    return true;
                });
            }
            if (events.length === 0) {
                container.innerHTML = html + `<div class="no-data">${t('noEventsMatchingFilters')}</div>`;
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            // Сортировка хард ликвидаций
            events.sort((a, b) => {
                let aVal, bVal;
                
                switch(hardSortColumn) {
                    case 'timestamp':
                        aVal = a.timestamp ? new Date(a.timestamp).getTime() : 0;
                        bVal = b.timestamp ? new Date(b.timestamp).getTime() : 0;
                        break;
                    case 'debt':
                        aVal = a.debt || 0;
                        bVal = b.debt || 0;
                        break;
                    case 'liquidation_discount':
                        aVal = a.liquidation_discount || 0;
                        bVal = b.liquidation_discount || 0;
                        break;
                    case 'market_name':
                    case 'platform':
                    case 'chain':
                    case 'user':
                    case 'liquidator':
                    case 'collateral_token':
                        aVal = (a[hardSortColumn] || '').toLowerCase();
                        bVal = (b[hardSortColumn] || '').toLowerCase();
                        break;
                    default:
                        aVal = a[hardSortColumn];
                        bVal = b[hardSortColumn];
                }
                
                if (hardSortDirection === 'asc') {
                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                    return bVal > aVal ? 1 : bVal < aVal ? -1 : 0;
                }
            });
            
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = events.slice(start, end);

            html += `
                <div class="table-wrapper">
                    <div class="table-header">
                        <h2 style="margin: 0;">🔥 ${t('hardLiquidations')}</h2>
                    </div>
                <div class="table-scroll-indicator" id="scrollHintHard">← ${t('swipeToScroll')} →</div>
                <table>
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortHardTable('timestamp')">
                                ${t('dateAndTime')} ${getHardSortArrow('timestamp')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('platform')">
                                ${t('platform')} ${getHardSortArrow('platform')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('market_name')">
                                ${t('market')} ${getHardSortArrow('market_name')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('chain')">
                                ${t('network')} ${getHardSortArrow('chain')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('user')">
                                ${t('user')} ${getHardSortArrow('user')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('liquidator')">
                                ${t('liquidator')} ${getHardSortArrow('liquidator')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('collateral_token')">
                                ${t('token')} ${getHardSortArrow('collateral_token')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('debt')">
                                ${t('debt')} ${getHardSortArrow('debt')}
                            </th>
                            <th class="sortable" onclick="sortHardTable('liquidation_discount')">
                                ${t('discount')} ${getHardSortArrow('liquidation_discount')}
                            </th>
                            <th>${t('txHash')}</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            pageData.forEach(event => {
                const date = new Date(event.timestamp);
                const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
                const dateTimeStr = `${date.toLocaleDateString(locale)} ${date.toLocaleTimeString(locale, {hour: '2-digit', minute: '2-digit', second: '2-digit'})}`;
                
                // Определяем правильный explorer в зависимости от сети
                let explorerUrl = '';
                if (event.transaction_hash) {
                    switch(event.chain) {
                        case 'ETHEREUM':
                            explorerUrl = `https://etherscan.io/tx/${event.transaction_hash}`;
                            break;
                        case 'ARBITRUM':
                            explorerUrl = `https://arbiscan.io/tx/${event.transaction_hash}`;
                            break;
                        case 'OPTIMISM':
                            explorerUrl = `https://optimistic.etherscan.io/tx/${event.transaction_hash}`;
                            break;
                        case 'POLYGON':
                            explorerUrl = `https://polygonscan.com/tx/${event.transaction_hash}`;
                            break;
                        case 'GNOSIS':
                            explorerUrl = `https://gnosisscan.io/tx/${event.transaction_hash}`;
                            break;
                        case 'BASE':
                            explorerUrl = `https://basescan.org/tx/${event.transaction_hash}`;
                            break;
                        case 'FRAXTAL':
                            explorerUrl = `https://fraxscan.com/tx/${event.transaction_hash}`;
                            break;
                        default:
                            explorerUrl = `https://etherscan.io/tx/${event.transaction_hash}`;
                    }
                }
                
                // Определяем базовый URL для адресов
                let addressBaseUrl = '';
                switch(event.chain) {
                    case 'ETHEREUM':
                        addressBaseUrl = 'https://etherscan.io/address/';
                        break;
                    case 'ARBITRUM':
                        addressBaseUrl = 'https://arbiscan.io/address/';
                        break;
                    case 'OPTIMISM':
                        addressBaseUrl = 'https://optimistic.etherscan.io/address/';
                        break;
                    case 'POLYGON':
                        addressBaseUrl = 'https://polygonscan.com/address/';
                        break;
                    case 'GNOSIS':
                        addressBaseUrl = 'https://gnosisscan.io/address/';
                        break;
                    case 'BASE':
                        addressBaseUrl = 'https://basescan.org/address/';
                        break;
                    case 'FRAXTAL':
                        addressBaseUrl = 'https://fraxscan.com/address/';
                        break;
                    default:
                        addressBaseUrl = 'https://etherscan.io/address/';
                }
                
                const txHashDisplay = event.transaction_hash ? 
                    `<a href="${explorerUrl}" target="_blank" title="${event.transaction_hash}" class="explorer-link">${event.transaction_hash.substring(0, 8)}...</a>` : 
                    'N/A';
                
                const userDisplay = event.user ? 
                    `<a href="${addressBaseUrl}${event.user}" target="_blank" title="${event.user}" class="explorer-link">${formatAddress(event.user)}</a>` : 
                    'N/A';
                
                const liquidatorDisplay = event.liquidator ? 
                    `<a href="${addressBaseUrl}${event.liquidator}" target="_blank" title="${event.liquidator}" class="explorer-link">${formatAddress(event.liquidator)}</a>` : 
                    'N/A';
                
                html += `
                    <tr>
                        <td>${dateTimeStr}</td>
                        <td>${event.platform || 'N/A'}</td>
                        <td>${event.market_name || 'N/A'}</td>
                        <td>${event.chain || 'N/A'}</td>
                        <td>${userDisplay}</td>
                        <td>${liquidatorDisplay}</td>
                        <td>${event.collateral_token || 'N/A'}</td>
                        <td>$${formatNumber(event.debt || 0)}</td>
                        <td>${((event.liquidation_discount || 0) * 100).toFixed(2)}%</td>
                        <td>${txHashDisplay}</td>
                    </tr>
                `;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
            
            // Check if table needs scrolling on mobile
            setTimeout(() => {
                const table = container.querySelector('table');
                const indicator = document.getElementById('scrollHintHard');
                if (table && indicator && window.innerWidth <= 768) {
                    if (table.scrollWidth > table.clientWidth) {
                        indicator.style.display = 'block';
                    } else {
                        indicator.style.display = 'none';
                    }
                }
            }, 100);
            
            renderPagination(events.length);
        }

        function changeComparisonGroup() {
            const select = document.getElementById('comparisonGroup');
            if (select) {
                comparisonGroupBy = select.value;
                currentPage = 1;
                renderData();
            }
        }
        
        function renderComparison(container) {
            // Add tab buttons with comparison selector
            let html = `
                <div style="display: flex; gap: 0; margin-bottom: 20px; align-items: center; justify-content: flex-end;">
                    <div style="display: inline-flex; gap: 2px; background: #f8f9fa; padding: 4px; border-radius: 6px;">
                        <button class="tab ${currentTab === 'soft' ? 'active' : ''}" onclick="window.switchTab('soft')" style="padding: 8px 16px;">
                            💧 ${t('softLiquidations')}
                        </button>
                        <button class="tab ${currentTab === 'hard' ? 'active' : ''}" onclick="window.switchTab('hard')" style="padding: 8px 16px;">
                            🔥 ${t('hardLiquidations')}
                        </button>
                        <button class="tab ${currentTab === 'comparison' ? 'active' : ''}" onclick="window.switchTab('comparison')" style="padding: 8px 16px;">
                            📊 ${t('comparison')}
                        </button>
                    </div>
                </div>
            `;
            
            if (!filteredSoftData || !filteredHardData) {
                container.innerHTML = html + `<div class="no-data">${currentLang === 'en' ? 'Insufficient data for comparison' : 'Недостаточно данных для сравнения'}</div>`;
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Собираем статистику в зависимости от типа группировки
            const stats = {};
            
            // First create a map of soft positions for duplicate detection
            const softPositionsMap = new Map();
            
            // Софт ликвидации
            if (filteredSoftData.positions) {
                // Фильтруем по датам если указаны
                let positions = filteredSoftData.positions;
                if (tableDateStart || tableDateEnd) {
                    positions = positions.filter(pos => {
                        if (!pos.first_dt) return false;
                        const openDate = new Date(pos.first_dt);
                        const closeDate = pos.last_dt ? new Date(pos.last_dt) : new Date();
                        
                        // Position is active if it overlaps with the date range
                        const rangeEnd = tableDateEnd || new Date();
                        const rangeStart = tableDateStart || new Date(0);
                        
                        return openDate <= rangeEnd && closeDate >= rangeStart;
                    });
                }
                
                // Build soft positions map for duplicate detection
                positions.forEach(pos => {
                    if (pos.user && pos.market_id) {
                        const key = `${pos.user}_${pos.market_id}`;
                        if (!softPositionsMap.has(key)) {
                            softPositionsMap.set(key, []);
                        }
                        softPositionsMap.get(key).push({
                            first_dt: pos.first_dt ? new Date(pos.first_dt) : null,
                            last_dt: pos.last_dt ? new Date(pos.last_dt) : new Date('2100-01-01')
                        });
                    }
                });
                
                positions.forEach(pos => {
                    let key, label;
                    
                    switch(comparisonGroupBy) {
                        case 'platform':
                            key = pos.platform;
                            label = pos.platform;
                            break;
                        case 'token':
                            key = pos.collateral_token;
                            label = pos.collateral_token;
                            break;
                        case 'chain':
                            key = pos.chain;
                            label = pos.chain;
                            break;
                        default: // market
                            key = `${pos.market_name}_${pos.platform}`;
                            label = pos.market_name;
                            break;
                    }
                    
                    if (!stats[key]) {
                        stats[key] = {
                            label: label,
                            market: pos.market_name,
                            platform: pos.platform,
                            chain: pos.chain,
                            token: pos.collateral_token,
                            softCount: 0,
                            softTVL: 0,
                            softDebt: 0,
                            hardCount: 0,
                            hardDebt: 0,
                            hardDuplicates: 0  // Track duplicate hard liquidations
                        };
                    }
                    stats[key].softCount++;
                    stats[key].softTVL += pos.tvl || 0;
                    stats[key].softDebt += pos.debt || 0;
                });
            }
            
            // Хард ликвидации
            if (filteredHardData.events) {
                // Фильтруем по датам если указаны
                let events = filteredHardData.events;
                if (tableDateStart || tableDateEnd) {
                    events = events.filter(event => {
                        if (!event.timestamp) return false;
                        const date = new Date(event.timestamp);
                        if (tableDateStart && date < tableDateStart) return false;
                        if (tableDateEnd && date > tableDateEnd) return false;
                        return true;
                    });
                }
                
                events.forEach((event, idx) => {
                    // Check if this hard liquidation is a duplicate of a soft position
                    let isDuplicate = false;
                    if (event.user && event.market_id && event.timestamp) {
                        const posKey = `${event.user}_${event.market_id}`;
                        const eventTime = new Date(event.timestamp);
                        const positions = softPositionsMap.get(posKey);
                        
                        if (positions) {
                            isDuplicate = positions.some(pos => {
                                const match = pos.first_dt && eventTime >= pos.first_dt && eventTime <= pos.last_dt;
                                return match;
                            });
                        }
                    }
                    
                    let key, label;
                    
                    switch(comparisonGroupBy) {
                        case 'platform':
                            key = event.platform;
                            label = event.platform;
                            break;
                        case 'token':
                            key = event.collateral_token;
                            label = event.collateral_token;
                            break;
                        case 'chain':
                            key = event.chain;
                            label = event.chain;
                            break;
                        default: // market
                            key = `${event.market_name}_${event.platform}`;
                            label = event.market_name;
                            break;
                    }
                    
                    if (!stats[key]) {
                        stats[key] = {
                            label: label,
                            market: event.market_name,
                            platform: event.platform,
                            chain: event.chain,
                            token: event.collateral_token,
                            softCount: 0,
                            softTVL: 0,
                            softDebt: 0,
                            hardCount: 0,
                            hardDebt: 0,
                            hardDuplicates: 0
                        };
                    }
                    stats[key].hardCount++;
                    stats[key].hardDebt += event.debt_with_discount || event.debt || 0;
                    if (isDuplicate) {
                        stats[key].hardDuplicates++;
                    }
                });
            }
            
            let statsArray = Object.values(stats);
            
            // Проверяем, есть ли данные после фильтрации
            if (statsArray.length === 0) {
                container.innerHTML = html + `<div class="no-data">${currentLang === 'en' ? 'No data in the selected date range' : 'Нет данных в выбранном диапазоне дат'}</div>`;
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            // Сортировка сравнения
            statsArray.sort((a, b) => {
                let aVal, bVal;
                
                switch(compareSortColumn) {
                    case 'softTVL':
                        aVal = a.softTVL;
                        bVal = b.softTVL;
                        break;
                    case 'softDebt':
                        aVal = a.softDebt;
                        bVal = b.softDebt;
                        break;
                    case 'softCount':
                        aVal = a.softCount;
                        bVal = b.softCount;
                        break;
                    case 'hardDebt':
                        aVal = a.hardDebt;
                        bVal = b.hardDebt;
                        break;
                    case 'hardCount':
                        aVal = a.hardCount;
                        bVal = b.hardCount;
                        break;
                    case 'protectedPositions':
                        aVal = Math.max(0, a.softCount - a.hardCount + (a.hardDuplicates || 0));
                        bVal = Math.max(0, b.softCount - b.hardCount + (b.hardDuplicates || 0));
                        break;
                    case 'protected':
                        aVal = a.softTVL - a.hardDebt;
                        bVal = b.softTVL - b.hardDebt;
                        break;
                    case 'label':
                    case 'market':
                    case 'platform':
                    case 'chain':
                        aVal = (a[compareSortColumn] || '').toLowerCase();
                        bVal = (b[compareSortColumn] || '').toLowerCase();
                        break;
                    default:
                        aVal = a[compareSortColumn];
                        bVal = b[compareSortColumn];
                }
                
                if (compareSortDirection === 'asc') {
                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                    return bVal > aVal ? 1 : bVal < aVal ? -1 : 0;
                }
            });
            
            if (statsArray.length === 0) {
                container.innerHTML = html + `<div class="no-data">${t('noData')}</div>`;
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageData = statsArray.slice(start, end);

            // Сохраняем текущее значение выбора
            const currentValue = comparisonGroupBy;
            
            // Append to existing HTML (which already has tabs)
            html += `
                <div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="margin: 0;">📊 ${t('comparison')}</h2>
                    <select id="comparisonGroup" onchange="changeComparisonGroup()" style="padding: 8px 12px; border-radius: 5px; border: 1px solid #ddd; background: white;">
                        <option value="market" ${comparisonGroupBy === 'market' ? 'selected' : ''}>${t('byMarkets')}</option>
                        <option value="platform" ${comparisonGroupBy === 'platform' ? 'selected' : ''}>${t('byPlatforms')}</option>
                        <option value="token" ${comparisonGroupBy === 'token' ? 'selected' : ''}>${t('byTokens')}</option>
                        <option value="chain" ${comparisonGroupBy === 'chain' ? 'selected' : ''}>${t('byNetworks')}</option>
                    </select>
                </div>
                <div class="table-scroll-indicator" id="scrollHintComparison">← ${t('swipeToScroll')} →</div>
                <table>
                    <thead>
                        <tr>`;
            
            // Динамические заголовки в зависимости от типа группировки
            switch(comparisonGroupBy) {
                case 'platform':
                    html += `
                        <th class="sortable" onclick="sortCompareTable('label')">
                            ${t('platform')} ${getCompareSortArrow('label')}
                        </th>`;
                    break;
                case 'token':
                    html += `
                        <th class="sortable" onclick="sortCompareTable('label')">
                            ${t('token')} ${getCompareSortArrow('label')}
                        </th>`;
                    break;
                case 'chain':
                    html += `
                        <th class="sortable" onclick="sortCompareTable('label')">
                            ${t('chain')} ${getCompareSortArrow('label')}
                        </th>`;
                    break;
                default: // market
                    html += `
                        <th class="sortable" onclick="sortCompareTable('platform')">
                            ${t('platform')} ${getCompareSortArrow('platform')}
                        </th>
                        <th class="sortable" onclick="sortCompareTable('label')">
                            ${t('market')} ${getCompareSortArrow('label')}
                        </th>`;
                    break;
            }
            
            html += `
                            <th class="sortable" onclick="sortCompareTable('softCount')">
                                ${t('softPositions')} ${getCompareSortArrow('softCount')}
                            </th>
                            <th class="sortable" onclick="sortCompareTable('softTVL')">
                                ${t('totalSoftTVL')} ${getCompareSortArrow('softTVL')}
                            </th>
                            <th class="sortable" onclick="sortCompareTable('softDebt')">
                                ${t('softDebt')} ${getCompareSortArrow('softDebt')}
                            </th>
                            <th class="sortable" onclick="sortCompareTable('hardCount')">
                                ${t('hardEvents')} ${getCompareSortArrow('hardCount')}
                            </th>
                            <th class="sortable" onclick="sortCompareTable('hardDebt')">
                                ${t('totalHardDebt')} ${getCompareSortArrow('hardDebt')}
                            </th>
                            <th class="sortable" onclick="sortCompareTable('protectedPositions')" title="${currentLang === 'en' ? 'Positions protected from hard liquidation' : 'Позиции защищенные от хард ликвидации'}">
                                ${currentLang === 'en' ? 'Protected Pos.' : 'Защищено поз.'} ${getCompareSortArrow('protectedPositions')}
                            </th>
                            <th class="sortable" onclick="sortCompareTable('protected')">
                                ${t('protected')} ${getCompareSortArrow('protected')}
                            </th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            pageData.forEach(stat => {
                const protected = stat.softTVL - stat.hardDebt;
                const protectedPercent = stat.softTVL > 0 ? (protected / stat.softTVL * 100) : 0;
                const protectedColor = protected > 0 ? 'green' : 'red';
                
                html += '<tr>';
                
                // Динамические колонки в зависимости от типа группировки
                switch(comparisonGroupBy) {
                    case 'platform':
                    case 'token':
                    case 'chain':
                        html += `<td>${stat.label || 'N/A'}</td>`;
                        break;
                    default: // market
                        html += `
                            <td>${stat.platform || 'N/A'}</td>
                            <td>${stat.label || 'N/A'}</td>`;
                        break;
                }
                
                html += `
                        <td>${stat.softCount}</td>
                        <td>$${formatNumber(stat.softTVL)}</td>
                        <td>$${formatNumber(stat.softDebt)}</td>
                        <td>${stat.hardCount}</td>
                        <td>$${formatNumber(stat.hardDebt)}</td>
                        <td style="color: green">${Math.max(0, stat.softCount - stat.hardCount + (stat.hardDuplicates || 0))}</td>
                        <td style="color: ${protectedColor}">
                            $${formatNumber(Math.abs(protected))} 
                            (${protectedPercent.toFixed(1)}%)
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
            
            // Check if table needs scrolling on mobile
            setTimeout(() => {
                const table = container.querySelector('table');
                const indicator = document.getElementById('scrollHintComparison');
                if (table && indicator && window.innerWidth <= 768) {
                    if (table.scrollWidth > table.clientWidth) {
                        indicator.style.display = 'block';
                    } else {
                        indicator.style.display = 'none';
                    }
                }
            }, 100);
            
            renderPagination(statsArray.length);
        }

        function renderPagination(totalItems) {
            const pagination = document.getElementById('pagination');
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            
            if (totalPages <= 1) {
                pagination.style.display = 'none';
                return;
            }
            
            let html = '';
            
            // Кнопка "Предыдущая"
            html += `<button class="page-btn" onclick="changePage(${currentPage - 1})" 
                     ${currentPage === 1 ? 'disabled' : ''}>◀</button>`;
            
            // Номера страниц
            const maxButtons = 7;
            let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
            let endPage = Math.min(totalPages, startPage + maxButtons - 1);
            
            if (endPage - startPage < maxButtons - 1) {
                startPage = Math.max(1, endPage - maxButtons + 1);
            }
            
            if (startPage > 1) {
                html += `<button class="page-btn" onclick="changePage(1)">1</button>`;
                if (startPage > 2) html += '<span>...</span>';
            }
            
            for (let i = startPage; i <= endPage; i++) {
                html += `<button class="page-btn ${i === currentPage ? 'active' : ''}" 
                         onclick="changePage(${i})">${i}</button>`;
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) html += '<span>...</span>';
                html += `<button class="page-btn" onclick="changePage(${totalPages})">${totalPages}</button>`;
            }
            
            // Кнопка "Следующая"
            html += `<button class="page-btn" onclick="changePage(${currentPage + 1})" 
                     ${currentPage === totalPages ? 'disabled' : ''}>▶</button>`;
            
            // Информация о странице
            html += `<span class="page-info">${t('pageText')} ${currentPage} ${t('ofPages')} ${totalPages} 
                     (${totalItems} ${t('records')})</span>`;
            
            pagination.innerHTML = html;
            pagination.style.display = 'flex';
        }

        function changePage(page) {
            currentPage = page;
            renderData();
            window.scrollTo(0, 0);
        }
        
        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            currentPage = 1;
            renderData();
        }
        
        function getSortArrow(column) {
            if (sortColumn !== column) return '';
            return sortDirection === 'asc' ? '↑' : '↓';
        }
        
        function sortHardTable(column) {
            if (hardSortColumn === column) {
                hardSortDirection = hardSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                hardSortColumn = column;
                hardSortDirection = 'desc';
            }
            currentPage = 1;
            renderData();
        }
        
        function getHardSortArrow(column) {
            if (hardSortColumn !== column) return '';
            return hardSortDirection === 'asc' ? '↑' : '↓';
        }
        
        function sortCompareTable(column) {
            if (compareSortColumn === column) {
                compareSortDirection = compareSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                compareSortColumn = column;
                compareSortDirection = 'desc';
            }
            currentPage = 1;
            renderData();
        }
        
        window.applyMainDateFilter = function() {
            const startInput = document.getElementById('mainDateStart');
            const endInput = document.getElementById('mainDateEnd');
            
            if (startInput.value) {
                tableDateStart = new Date(startInput.value);
                selectedStartDate = tableDateStart;
            }
            if (endInput.value) {
                tableDateEnd = new Date(endInput.value);
                selectedEndDate = tableDateEnd;
            }
            
            // Обновляем слайдер чтобы он соответствовал выбранным датам
            updateSliderFromDates();
            
            // Применяем фильтр ко всем вкладкам
            applyFilters();
            renderChart();
            document.getElementById('mainDatePicker').classList.remove('active');
        }
        
        window.resetMainDateFilter = function() {
            document.getElementById('mainDateStart').value = '';
            document.getElementById('mainDateEnd').value = '';
            tableDateStart = null;
            tableDateEnd = null;
            
            // Сбрасываем слайдер на полный период
            const totalDays = parseInt(rangeEnd.max);
            rangeStart.value = 0;
            rangeEnd.value = totalDays;
            
            // Обновляем визуальный диапазон
            const startPercent = (rangeStart.value / totalDays) * 100;
            const endPercent = (rangeEnd.value / totalDays) * 100;
            sliderRange.style.left = startPercent + '%';
            sliderRange.style.width = (endPercent - startPercent) + '%';
            
            // Обновляем selectedStartDate и selectedEndDate
            const minDate = globalMinDate || new Date();
            const maxDate = globalMaxDate || new Date();
            const dayRange = (maxDate - minDate) / (24 * 60 * 60 * 1000);
            const max = parseInt(rangeStart.max);
            selectedStartDate = new Date(minDate.getTime() + (parseInt(rangeStart.value) / max) * dayRange * 24 * 60 * 60 * 1000);
            selectedEndDate = new Date(minDate.getTime() + (parseInt(rangeEnd.value) / max) * dayRange * 24 * 60 * 60 * 1000);
            
            applyFilters();
            renderChart();
            document.getElementById('mainDatePicker').classList.remove('active');
        }
        
        window.toggleDatePicker = function(type) {
            let pickerId;
            if (type === 'main') {
                pickerId = 'mainDatePicker';
            } else if (type === 'soft') {
                pickerId = 'softDatePicker';
            } else {
                pickerId = 'hardDatePicker';
            }
            const picker = document.getElementById(pickerId);
            if (picker) {
                picker.classList.toggle('active');
                // Закрываем другой календарь если открыт
                const otherId = type === 'soft' ? 'hardDatePicker' : 'softDatePicker';
                const otherPicker = document.getElementById(otherId);
                if (otherPicker) {
                    otherPicker.classList.remove('active');
                }
            }
        }
        
        function getCompareSortArrow(column) {
            if (compareSortColumn !== column) return '';
            return compareSortDirection === 'asc' ? '↑' : '↓';
        }

        function formatNumber(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(2);
        }

        function formatAddress(address) {
            if (!address) return 'N/A';
            return address.slice(0, 6) + '...' + address.slice(-4);
        }
        
        function formatDateTime(dateStr) {
            if (!dateStr) return 'N/A';
            const date = new Date(dateStr);
            const options = { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            };
            return date.toLocaleString('ru-RU', options);
        }
        
        function formatDuration(hours) {
            const roundedHours = Math.round(hours * 10) / 10; // Округляем до 1 знака после запятой
            if (roundedHours < 24) {
                return `${roundedHours.toFixed(1)} ч`;
            } else {
                const days = Math.floor(roundedHours / 24);
                const remainingHours = Math.round(roundedHours % 24);
                if (remainingHours === 0) {
                    return `${days}д`;
                }
                return `${days}д ${remainingHours}ч`;
            }
        }

        function showError(message) {
            const dataTable = document.getElementById('dataTable');
            dataTable.innerHTML = `<div class="error">${message}</div>`;
        }

        // Функции для работы с календарем
        let currentDatePickerType = null; // 'start' или 'end'
        
        window.openDatePicker = function(type) {
            currentDatePickerType = type;
            const datePickerPopup = document.getElementById('datePickerPopup');
            const datePickerInput = document.getElementById('datePickerInput');
            const label = document.getElementById(type + 'Label');
            
            // Обновляем текст кнопок в зависимости от языка
            document.getElementById('applyDateBtn').textContent = t('apply');
            document.getElementById('cancelDateBtn').textContent = t('cancel');
            
            // Устанавливаем текущую дату в input
            const currentDate = type === 'start' ? selectedStartDate : selectedEndDate;
            if (currentDate) {
                datePickerInput.value = currentDate.toISOString().split('T')[0];
            }
            
            // Позиционируем календарь под лейблом
            const rect = label.getBoundingClientRect();
            const container = label.closest('.combined-container');
            const containerRect = container.getBoundingClientRect();
            
            // Вычисляем позицию относительно контейнера
            let leftPos = rect.left - containerRect.left;
            const topPos = rect.bottom - containerRect.top + 5;
            
            // Для правой даты (end) сдвигаем влево на 70px
            if (type === 'end') {
                leftPos = leftPos - 70;
            }
            
            datePickerPopup.style.left = leftPos + 'px';
            datePickerPopup.style.top = topPos + 'px';
            datePickerPopup.style.display = 'block';
        }
        
        window.closeDatePicker = function() {
            document.getElementById('datePickerPopup').style.display = 'none';
            currentDatePickerType = null;
        }
        
        window.applyDateFromPicker = function() {
            const datePickerInput = document.getElementById('datePickerInput');
            const selectedDate = new Date(datePickerInput.value);
            
            if (!selectedDate || isNaN(selectedDate.getTime())) {
                alert(t('selectValidDate'));
                return;
            }
            
            // Обновляем соответствующую дату
            if (currentDatePickerType === 'start') {
                selectedStartDate = selectedDate;
                tableDateStart = selectedDate;
            } else if (currentDatePickerType === 'end') {
                selectedEndDate = selectedDate;
                tableDateEnd = selectedDate;
            }
            
            // Обновляем слайдер в соответствии с выбранными датами
            updateSliderFromDates();
            
            // Закрываем календарь
            closeDatePicker();
            
            // Применяем фильтры
            if (typeof applyFilters === 'function') {
                applyFilters();
            }
        }
        
        // Автозагрузка при открытии страницы
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize language button states based on saved language
            const enBtn = document.getElementById('langEn');
            const ruBtn = document.getElementById('langRu');
            if (currentLang === 'ru') {
                ruBtn.style.background = 'white';
                ruBtn.style.color = '#333';
                enBtn.style.background = 'rgba(255,255,255,0.2)';
                enBtn.style.color = 'white';
            } else {
                enBtn.style.background = 'white';
                enBtn.style.color = '#333';
                ruBtn.style.background = 'rgba(255,255,255,0.2)';
                ruBtn.style.color = 'white';
            }
            
            // Добавляем обработчики для двустороннего слайдера
            const rangeStart = document.getElementById('rangeStart');
            const rangeEnd = document.getElementById('rangeEnd');
            const sliderRange = document.getElementById('sliderRange');
            const startLabel = document.getElementById('startLabel');
            const endLabel = document.getElementById('endLabel');
            
            function updateSliderRange() {
                const start = parseInt(rangeStart.value);
                const end = parseInt(rangeEnd.value);
                const max = parseInt(rangeStart.max);
                
                // Не даем слайдерам пересекаться
                if (start >= end) {
                    if (this === rangeStart) {
                        rangeStart.value = end - 1;
                    } else {
                        rangeEnd.value = start + 1;
                    }
                    return;
                }
                
                // Обновляем визуальный диапазон
                const startPercent = (start / max) * 100;
                const endPercent = (end / max) * 100;
                sliderRange.style.left = startPercent + '%';
                sliderRange.style.width = (endPercent - startPercent) + '%';
                
                // Обновляем метки с учетом текущего диапазона дат (фильтрованных или полных)
                let minDate = new Date();
                let maxDate = new Date(0);
                
                // Используем отфильтрованные данные если есть
                const softToUse = filteredSoftData || softData;
                const hardToUse = filteredHardData || hardData;
                
                if (softToUse && softToUse.positions) {
                    softToUse.positions.forEach(pos => {
                        if (pos.first_dt) {
                            const date = new Date(pos.first_dt);
                            if (date < minDate) minDate = date;
                            if (date > maxDate) maxDate = date;
                        }
                    });
                }
                
                if (hardToUse && hardToUse.events) {
                    hardToUse.events.forEach(event => {
                        if (event.timestamp) {
                            const date = new Date(event.timestamp);
                            if (date < minDate) minDate = date;
                            if (date > maxDate) maxDate = date;
                        }
                    });
                }
                
                // Если данных нет, используем глобальный диапазон
                if (minDate > maxDate && globalMinDate && globalMaxDate) {
                    minDate = globalMinDate;
                    maxDate = globalMaxDate;
                }
                
                // Вычисляем и сохраняем выбранные даты
                const dayRange = (maxDate - minDate) / (24 * 60 * 60 * 1000);
                selectedStartDate = new Date(minDate.getTime() + (start / max) * dayRange * 24 * 60 * 60 * 1000);
                selectedEndDate = new Date(minDate.getTime() + (end / max) * dayRange * 24 * 60 * 60 * 1000);
                
                // Обновляем глобальные переменные для фильтрации таблицы
                tableDateStart = selectedStartDate;
                tableDateEnd = selectedEndDate;
                
                // Обновляем Date Filter чтобы он соответствовал слайдеру
                const mainDateStart = document.getElementById('mainDateStart');
                const mainDateEnd = document.getElementById('mainDateEnd');
                if (mainDateStart) {
                    mainDateStart.value = selectedStartDate.toISOString().split('T')[0];
                }
                if (mainDateEnd) {
                    mainDateEnd.value = selectedEndDate.toISOString().split('T')[0];
                }
                
                const locale = currentLang === 'en' ? 'en-US' : 'ru-RU';
                startLabel.textContent = selectedStartDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
                endLabel.textContent = selectedEndDate.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: '2-digit'});
                
                // Перерисовываем график и данные таблицы
                renderStats();
            // Update the inline protection chart after stats are rendered
            setTimeout(() => updateProtectionChartInline(), 100);  // Обновляем блоки статистики
                renderChart();
                renderData();  // Обновляем таблицу и диаграммы с учетом нового диапазона дат
                updateFilterStats();  // Обновляем счетчик отфильтрованных данных
                updateProtectionChart();  // Обновляем диаграмму защиты
            }
            
            // Функция для обновления слайдера на основе выбранных дат
            function updateSliderFromDates() {
                if (!selectedStartDate || !selectedEndDate) return;
                
                // Находим минимальную и максимальную даты в данных
                let minDate = globalMinDate || new Date();
                let maxDate = globalMaxDate || new Date();
                
                // Вычисляем позиции слайдера
                const totalDays = Math.ceil((maxDate - minDate) / (24 * 60 * 60 * 1000)) + 1;
                const startDay = Math.max(0, Math.floor((selectedStartDate - minDate) / (24 * 60 * 60 * 1000)));
                const endDay = Math.min(totalDays, Math.ceil((selectedEndDate - minDate) / (24 * 60 * 60 * 1000)));
                
                // Обновляем слайдер
                rangeStart.value = startDay;
                rangeEnd.value = endDay;
                
                // Обновляем визуальный диапазон
                const startPercent = (startDay / totalDays) * 100;
                const endPercent = (endDay / totalDays) * 100;
                sliderRange.style.left = startPercent + '%';
                sliderRange.style.width = (endPercent - startPercent) + '%';
            }
            window.updateSliderFromDates = updateSliderFromDates;
            
            rangeStart.addEventListener('input', updateSliderRange);
            rangeEnd.addEventListener('input', updateSliderRange);
            
            try {
                await loadScriptByName('latest_liquidations_final.js');
                if (window.SOFT_LIQUIDATIONS_DATA) {
                    processLoadedData(window.SOFT_LIQUIDATIONS_DATA);
                    const fileNameElement = document.getElementById('fileName');
                    if (fileNameElement) {
                        fileNameElement.textContent = currentLang === 'en' ? 'latest_liquidations_final.js loaded' : 'latest_liquidations_final.js загружен';
                    }
                }
            } catch (error) {
                const fileNameElement = document.getElementById('fileName');
                if (fileNameElement) {
                    fileNameElement.textContent = currentLang === 'en' ? 'Select file to load' : 'Выберите файл для загрузки';
                }
            }
        });
        
        // Helper function to setup canvas for high DPI displays (moved here to be available for all functions)
        function setupHighDPICanvas(canvas, width, height) {
            const dpr = window.devicePixelRatio || 1;
            
            // Set the actual dimensions
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            
            // Scale the canvas back down using CSS
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            // Scale the drawing context so everything draws at the correct size
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            
            return ctx;
        }
        
        // Function to update the protection chart
        function updateProtectionChartInline() {
            const canvas = document.getElementById('protectionChartInline');
            if (!canvas) return;
            
            // Read values directly from the protection card to ensure consistency
            const protectionCard = document.querySelector('.stat-card.protection');
            if (!protectionCard) return;
            
            // Check if card has negative class (this determines the background color)
            const isCardNegative = protectionCard.classList.contains('negative');
            
            // Extract the displayed values from the card
            const valueElement = protectionCard.querySelector('.stat-value');
            const percentElement = protectionCard.querySelector('.protection-percent span');
            
            let protectedAmount = 0;
            let protectionPercent = 0;
            
            // Parse the displayed value (it's always positive in display, check card class for sign)
            if (valueElement) {
                const displayedValue = valueElement.textContent.replace(/[^0-9.]/g, '');
                protectedAmount = parseFloat(displayedValue) || 0;
                if (isCardNegative) {
                    protectedAmount = -protectedAmount;
                }
            }
            
            // Parse the percentage from the displayed text
            if (percentElement) {
                const percentMatch = percentElement.textContent.match(/-?\d+\.?\d*/);
                if (percentMatch) {
                    protectionPercent = parseFloat(percentMatch[0]);
                }
            }
            
            // Set canvas size with high DPI support
            const width = 180;
            const height = 180;
            const ctx = setupHighDPICanvas(canvas, width, height);
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 15;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background circle (track)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 20;
            ctx.stroke();
            
            // Draw protection arc
            const startAngle = -Math.PI / 2;
            const endAngle = startAngle + (2 * Math.PI * protectionPercent / 100);
            
            // Create gradient for the arc - match the card's background color
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            if (!isCardNegative) {  // Use card's state directly
                // White to light gray for positive protection (green background)
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, '#f0f0f0');
            } else {
                // Red tones for negative protection (red background)
                gradient.addColorStop(0, '#ff6b6b');
                gradient.addColorStop(1, '#ff4444');
            }
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.stroke();
            
        }
        
        // Compatibility wrapper for old function name
        function updateProtectionChart() {
            updateProtectionChartInline();
        }
        
        // Function to switch distribution chart type
        function switchDistributionChart(type) {
            // Update radio button
            const radio = document.querySelector(`input[name="distributionType"][value="${type}"]`);
            if (radio) {
                radio.checked = true;
            }
            
            // Draw the selected chart - use pie chart instead of treemap
            if (window.chartData && window.chartData[type]) {
                // Determine chart type based on current tab
                let chartType;
                if (currentTab === 'hard') {
                    chartType = 'hard';
                } else if (currentTab === 'comparison') {
                    chartType = 'comparison';
                } else {
                    chartType = 'soft';
                }
                drawPieChartWithLabels('distributionChart', window.chartData[type], chartType);
            }
        }
        
        // Function to draw treemap chart for distributions (like stock market apps)
        function drawRectChart(containerId, data) {
            const container = document.getElementById(containerId);
            if (!container || !data || data.length === 0) return;
            
            // Clear container
            container.innerHTML = '';
            
            // Calculate total and percentages
            const total = data.reduce((sum, item) => sum + item.value, 0);
            if (total === 0) return;
            
            // Sort data by value (descending)
            const sortedData = [...data].sort((a, b) => b.value - a.value);
            
            // Take top 10 items for better layout
            const displayData = sortedData.slice(0, 10);
            
            // Colors palette - green for largest, distinct colors for others
            const colors = [
                '#22c55e', // GREEN for #1 largest sector
                '#3b82f6', // blue
                '#f97316', // orange
                '#8b5cf6', // purple
                '#ef4444', // red
                '#fbbf24', // yellow
                '#06b6d4', // cyan
                '#ec4899', // pink
                '#84cc16', // lime
                '#f59e0b', // amber
                '#6366f1', // indigo
                '#14b8a6', // teal
                '#f472b6', // rose
                '#a78bfa', // violet
                '#fb7185', // light red
                '#34d399'  // emerald
            ];
            
            // Container dimensions
            const containerWidth = 290;
            const containerHeight = 280;
            
            // Create treemap container
            const treemapContainer = document.createElement('div');
            treemapContainer.style.cssText = `
                width: ${containerWidth}px;
                height: ${containerHeight}px;
                position: relative;
                background: rgba(255,255,255,0.05);
                border-radius: 6px;
            `;
            
            // Simple treemap algorithm - squarified layout
            function squarify(data, x, y, width, height) {
                if (data.length === 0) return;
                
                if (data.length === 1) {
                    const item = data[0];
                    const percentage = (item.value / total) * 100;
                    const rect = createRect(item, colors[item.index % colors.length], x, y, width, height, percentage);
                    treemapContainer.appendChild(rect);
                    return;
                }
                
                // Split into two groups
                const totalValue = data.reduce((sum, item) => sum + item.value, 0);
                const mid = Math.floor(data.length / 2);
                
                let sum1 = 0;
                for (let i = 0; i < mid; i++) {
                    sum1 += data[i].value;
                }
                
                const ratio1 = sum1 / totalValue;
                
                if (width > height) {
                    // Split vertically
                    const w1 = width * ratio1;
                    squarify(data.slice(0, mid), x, y, w1, height);
                    squarify(data.slice(mid), x + w1, y, width - w1, height);
                } else {
                    // Split horizontally  
                    const h1 = height * ratio1;
                    squarify(data.slice(0, mid), x, y, width, h1);
                    squarify(data.slice(mid), x, y + h1, width, height - h1);
                }
            }
            
            function createRect(item, color, x, y, width, height, percentage) {
                const rect = document.createElement('div');
                
                rect.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: ${width}px;
                    height: ${height}px;
                    background: ${color};
                    border: 1px solid rgba(255,255,255,0.1);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    color: white;
                    font-size: ${Math.min(Math.max(width / 12, 8), 12)}px;
                    font-weight: 600;
                    text-align: center;
                    padding: 4px;
                    box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
                    transition: all 0.2s ease;
                    cursor: pointer;
                    overflow: hidden;
                    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
                    box-sizing: border-box;
                `;
                
                // Add hover effect with tooltip
                rect.addEventListener('mouseenter', (e) => {
                    rect.style.transform = 'scale(1.05)';
                    rect.style.zIndex = '10';
                    rect.style.boxShadow = 'inset 0 1px 0 rgba(255,255,255,0.2), 0 4px 12px rgba(0,0,0,0.3)';
                    
                    // Create tooltip
                    const tooltip = document.createElement('div');
                    tooltip.id = 'treemap-tooltip';
                    tooltip.style.cssText = `
                        position: fixed;
                        background: rgba(0,0,0,0.9);
                        color: white;
                        padding: 12px;
                        border-radius: 8px;
                        font-size: 12px;
                        line-height: 1.4;
                        max-width: 200px;
                        z-index: 1000;
                        pointer-events: none;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                        border: 1px solid rgba(255,255,255,0.1);
                        backdrop-filter: blur(10px);
                    `;
                    
                    // Format both count and dollar values
                    const countValue = item.count ? item.count.toLocaleString('en-US') : item.value.toLocaleString('en-US');
                    const dollarValue = new Intl.NumberFormat('en-US', {
                        style: 'currency',
                        currency: 'USD',
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0
                    }).format(item.dollars || item.value);
                    
                    // Show both count and dollars
                    tooltip.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 6px; color: ${color};">${item.label}</div>
                        <div style="margin-bottom: 3px;">${t('count')}: <strong>${countValue}</strong></div>
                        <div style="margin-bottom: 3px;">${currentTab === 'comparison' ? (t('protected') || 'Protected') : t('value')}: <strong>${dollarValue}</strong></div>
                        <div style="margin-bottom: 3px;">${t('share')}: <strong>${percentage.toFixed(2)}%</strong></div>
                        <div style="font-size: 11px; opacity: 0.8;">Rank: #${item.index + 1}</div>
                    `;
                    
                    document.body.appendChild(tooltip);
                    
                    // Position tooltip
                    const updateTooltipPosition = (event) => {
                        const rect = tooltip.getBoundingClientRect();
                        const x = event.clientX + 10;
                        const y = event.clientY - rect.height - 10;
                        
                        // Keep tooltip within viewport
                        const finalX = Math.min(x, window.innerWidth - rect.width - 10);
                        const finalY = Math.max(y, 10);
                        
                        tooltip.style.left = finalX + 'px';
                        tooltip.style.top = finalY + 'px';
                    };
                    
                    updateTooltipPosition(e);
                    
                    // Update position on mouse move
                    rect._mouseMoveHandler = updateTooltipPosition;
                    rect.addEventListener('mousemove', rect._mouseMoveHandler);
                });
                
                rect.addEventListener('mouseleave', () => {
                    rect.style.transform = 'scale(1)';
                    rect.style.zIndex = '1';
                    rect.style.boxShadow = 'inset 0 1px 0 rgba(255,255,255,0.1)';
                    
                    // Remove tooltip
                    const tooltip = document.getElementById('treemap-tooltip');
                    if (tooltip) {
                        tooltip.remove();
                    }
                    
                    // Remove mouse move handler
                    if (rect._mouseMoveHandler) {
                        rect.removeEventListener('mousemove', rect._mouseMoveHandler);
                        rect._mouseMoveHandler = null;
                    }
                });
                
                // Only show text if rectangle is big enough
                if (width > 40 && height > 25) {
                    // Create label
                    const label = document.createElement('div');
                    let displayName = item.label;
                    if (width < 80 && displayName.length > 6) {
                        displayName = displayName.substring(0, 6) + '...';
                    } else if (displayName.length > 10) {
                        displayName = displayName.substring(0, 10) + '...';
                    }
                    label.textContent = displayName;
                    label.style.cssText = `
                        font-size: ${Math.min(Math.max(width / 15, 8), 11)}px;
                        line-height: 1.1;
                        margin-bottom: 2px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        max-width: 100%;
                    `;
                    
                    // Create percentage - only if there's space
                    if (height > 40) {
                        const percent = document.createElement('div');
                        percent.textContent = `${percentage.toFixed(1)}%`;
                        percent.style.cssText = `
                            font-size: ${Math.min(Math.max(width / 18, 7), 10)}px;
                            font-weight: 700;
                            opacity: 0.9;
                        `;
                        rect.appendChild(label);
                        rect.appendChild(percent);
                    } else {
                        rect.appendChild(label);
                    }
                } else if (width > 25 && height > 15) {
                    // Very small - just percentage
                    const percent = document.createElement('div');
                    percent.textContent = `${percentage.toFixed(0)}%`;
                    percent.style.cssText = `
                        font-size: 8px;
                        font-weight: 700;
                    `;
                    rect.appendChild(percent);
                }
                
                return rect;
            }
            
            // Add indexes to data for color consistency
            const indexedData = displayData.map((item, index) => ({ ...item, index }));
            
            // Start recursive layout
            squarify(indexedData, 0, 0, containerWidth, containerHeight);
            
            container.appendChild(treemapContainer);
        }

        // COMPLETELY REWRITTEN PIE CHART FUNCTION
        function drawPieChartWithLabels(canvasId, data, chartType) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !data || data.length === 0) return;
            
            // Configuration
            const width = 280;
            const height = 260;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 20;
            
            // Setup high DPI canvas
            const ctx = setupHighDPICanvas(canvas, width, height);
            ctx.clearRect(0, 0, width, height);
            
            // Prepare data: sort and create segments
            const sortedData = [...data]
                .filter(item => item.value > 0)
                .sort((a, b) => b.value - a.value);
            
            // Create segments array with top 8 + others
            const segments = [];
            const topItems = sortedData.slice(0, 8);
            const remainingItems = sortedData.slice(8);
            
            // Add top items
            topItems.forEach(item => segments.push({...item}));
            
            // Add "Others" segment if needed
            if (remainingItems.length > 0) {
                const othersValue = remainingItems.reduce((sum, item) => sum + item.value, 0);
                const othersCount = remainingItems.reduce((sum, item) => sum + (item.count || 1), 0);
                const othersDollars = remainingItems.reduce((sum, item) => sum + (item.dollars || item.value), 0);
                
                segments.push({
                    label: t('others') || 'Others',
                    value: othersValue,
                    count: othersCount,
                    dollars: othersDollars,
                    items: remainingItems,
                    isOthers: true
                });
            }
            
            // Calculate total from segments (ensures consistency)
            const total = segments.reduce((sum, seg) => sum + seg.value, 0);
            if (total === 0) return;
            
            // Color palette
            const colors = [
                '#22c55e', // green
                '#3b82f6', // blue
                '#f97316', // orange
                '#8b5cf6', // purple
                '#ef4444', // red
                '#fbbf24', // yellow
                '#06b6d4', // cyan
                '#ec4899', // pink
            ];
            
            // Store segment angles for hover detection
            const segmentAngles = [];
            let startAngle = -Math.PI / 2; // Start from top
            
            // Draw all segments
            segments.forEach((segment, index) => {
                const segmentValue = segment.value;
                const angle = (segmentValue / total) * 2 * Math.PI;
                const endAngle = startAngle + angle;
                
                // Store angles for hover detection
                segmentAngles.push({
                    startAngle: startAngle,
                    endAngle: endAngle,
                    segment: segment,
                    color: segment.isOthers ? '#555' : colors[index % colors.length],
                    percentage: (segmentValue / total) * 100
                });
                
                // Draw segment with shadow
                ctx.save();
                
                // Add shadow for depth (like bar chart)
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
                
                // Draw segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                
                // Fill with color
                const segmentColor = segment.isOthers ? '#555' : colors[index % colors.length];
                ctx.fillStyle = segmentColor;
                ctx.fill();
                
                // Remove shadow for border
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                ctx.restore();
                
                // Draw label for segments > 5%
                const percentage = (segmentValue / total) * 100;
                if (percentage > 5) {
                    const labelAngle = startAngle + angle / 2;
                    const labelRadius = radius * 0.7;
                    const labelX = centerX + Math.cos(labelAngle) * labelRadius;
                    const labelY = centerY + Math.sin(labelAngle) * labelRadius;
                    
                    // Draw text with shadow
                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 3;
                    
                    // Label text
                    const labelText = segment.label.length > 10 ? 
                        segment.label.substring(0, 10) + '...' : 
                        segment.label;
                    ctx.fillText(labelText, labelX, labelY - 6);
                    
                    // Percentage
                    ctx.font = '10px Arial';
                    ctx.fillText(`${percentage.toFixed(1)}%`, labelX, labelY + 6);
                    ctx.restore();
                }
                
                startAngle = endAngle;
            });
            
            // Store data for hover detection
            canvas.pieData = {
                segments: segmentAngles,
                centerX: centerX,
                centerY: centerY,
                radius: radius,
                chartType: chartType
            };
            
            // Remove old event listeners
            canvas.onmousemove = null;
            canvas.onmouseleave = null;
            
            // Add new hover handler
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (width / rect.width);
                const y = (e.clientY - rect.top) * (height / rect.height);
                
                // Check if mouse is over pie
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= radius && canvas.pieData) {
                    // Calculate angle
                    let mouseAngle = Math.atan2(dy, dx);
                    // Normalize to 0-2π range starting from top
                    mouseAngle = mouseAngle + Math.PI / 2;
                    if (mouseAngle < 0) mouseAngle += 2 * Math.PI;
                    if (mouseAngle > 2 * Math.PI) mouseAngle -= 2 * Math.PI;
                    
                    // Find which segment
                    for (let segData of canvas.pieData.segments) {
                        let start = segData.startAngle + Math.PI / 2;
                        let end = segData.endAngle + Math.PI / 2;
                        
                        // Normalize angles
                        if (start < 0) start += 2 * Math.PI;
                        if (end < 0) end += 2 * Math.PI;
                        
                        // Check if mouse angle is within segment
                        let inSegment = false;
                        if (start <= end) {
                            inSegment = mouseAngle >= start && mouseAngle <= end;
                        } else {
                            // Segment crosses 0
                            inSegment = mouseAngle >= start || mouseAngle <= end;
                        }
                        
                        if (inSegment) {
                            canvas.style.cursor = 'pointer';
                            const chartType = canvas.pieData?.chartType || null;
                            showTooltip(e, segData.segment, segData.percentage, chartType);
                            return;
                        }
                    }
                }
                
                // Not hovering over pie
                canvas.style.cursor = 'default';
                hideTooltip();
            });
            
            canvas.addEventListener('mouseleave', function() {
                canvas.style.cursor = 'default';
                hideTooltip();
            });
        }
        
        // Helper function to adjust color brightness
        function adjustColorBrightness(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        // Tooltip functions for pie chart
        let currentTooltip = null;
        
        function showTooltip(event, item, percentage, chartType) {
            hideTooltip(); // Remove any existing tooltip
            
            const tooltip = document.createElement('div');
            tooltip.id = 'pie-tooltip';
            tooltip.style.cssText = `
                position: fixed;
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 12px;
                border-radius: 8px;
                font-size: 12px;
                line-height: 1.4;
                z-index: 1000;
                pointer-events: none;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.1);
                backdrop-filter: blur(10px);
                max-width: 200px;
            `;
            
            // Determine chart type label
            let typeLabel = '';
            let typeColor = '#22c55e';
            let typeIcon = '';
            
            // Try to determine chart type from context
            const canvasId = event.target?.id || '';
            const isProtectionChart = canvasId.includes('protection');
            const distributionType = document.querySelector('input[name="distributionType"]:checked')?.value;
            
            if (chartType === 'comparison' || isProtectionChart) {
                // Remove emoji from translation if it exists
                const protectionText = t('protectedFromLiquidation') || 'Protected from Liquidation';
                typeLabel = protectionText.replace('🛡️', '').trim();
                typeColor = '#3b82f6';
                typeIcon = '🛡️';
            } else if (chartType === 'soft' || distributionType === 'soft') {
                typeLabel = t('softLiquidations') || 'Soft Liquidations';
                typeColor = '#22c55e';
                typeIcon = '💧';
            } else if (chartType === 'hard' || distributionType === 'hard') {
                typeLabel = t('hardLiquidations') || 'Hard Liquidations';
                typeColor = '#ff6b6b';
                typeIcon = '🔥';
            }
            
            // Format both count and dollar values
            const countValue = item.count ? item.count.toLocaleString('en-US') : item.value.toLocaleString('en-US');
            const dollarValue = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(item.dollars || item.value);
            
            // Check if this is the "Others" item
            if (item.isOthers && item.items) {
                // Show detailed info for Others
                let detailsHtml = '';
                const topItems = item.items.slice(0, 5); // Show top 5 items
                topItems.forEach(subItem => {
                    const subPercent = ((subItem.value / item.value) * 100).toFixed(1);
                    detailsHtml += `
                        <div style="margin-left: 10px; font-size: 10px; opacity: 0.8;">
                            • ${subItem.label}: ${subPercent}%
                        </div>
                    `;
                });
                if (item.items.length > 5) {
                    const moreText = t('andMore').replace('{count}', item.items.length - 5);
                    detailsHtml += `
                        <div style="margin-left: 10px; font-size: 10px; opacity: 0.6;">
                            ... ${moreText}
                        </div>
                    `;
                }
                
                tooltip.innerHTML = `
                    ${typeLabel ? `<div style="font-size: 11px; font-weight: 600; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.2); color: ${typeColor};">${typeIcon} ${typeLabel}</div>` : ''}
                    <div style="font-weight: 600; margin-bottom: 6px; color: #888;">${item.label}</div>
                    <div style="margin-bottom: 3px;">${t('count')}: <strong>${countValue}</strong></div>
                    <div style="margin-bottom: 3px;">${currentTab === 'comparison' ? (t('protected') || 'Protected') : t('value')}: <strong>${dollarValue}</strong></div>
                    <div style="margin-bottom: 3px;">${t('share')}: <strong>${percentage.toFixed(2)}%</strong></div>
                    <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.2);">
                        <div style="font-size: 11px; margin-bottom: 4px; opacity: 0.9;">${t('includes')}:</div>
                        ${detailsHtml}
                    </div>
                `;
            } else {
                // Show regular tooltip
                tooltip.innerHTML = `
                    ${typeLabel ? `<div style="font-size: 11px; font-weight: 600; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.2); color: ${typeColor};">${typeIcon} ${typeLabel}</div>` : ''}
                    <div style="font-weight: 600; margin-bottom: 6px; color: #22c55e;">${item.label}</div>
                    <div style="margin-bottom: 3px;">${t('count')}: <strong>${countValue}</strong></div>
                    <div style="margin-bottom: 3px;">${currentTab === 'comparison' ? (t('protected') || 'Protected') : t('value')}: <strong>${dollarValue}</strong></div>
                    <div>${t('share')}: <strong>${percentage.toFixed(2)}%</strong></div>
                `;
            }
            
            document.body.appendChild(tooltip);
            currentTooltip = tooltip;
            
            // Position tooltip
            const rect = tooltip.getBoundingClientRect();
            const x = event.clientX + 10;
            const y = event.clientY - rect.height - 10;
            
            const finalX = Math.min(x, window.innerWidth - rect.width - 10);
            const finalY = Math.max(y, 10);
            
            tooltip.style.left = finalX + 'px';
            tooltip.style.top = finalY + 'px';
        }
        
        function hideTooltip() {
            if (currentTooltip) {
                currentTooltip.remove();
                currentTooltip = null;
            }
        }
        
        // Function to draw pie charts for distributions - SIMPLIFIED VERSION
        function drawPieChart(canvasId, data, legendId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                return;
            }
            
            // Set canvas size
            const width = 300;
            const height = 300;
            
            // Setup high DPI canvas
            const ctx = setupHighDPICanvas(canvas, width, height);
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 60;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            if (!data || data.length === 0) {
                ctx.fillStyle = '#ccc';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(t('noData'), centerX, centerY);
                return;
            }
            
            // Sort data by value (descending) and filter out invalid values
            const sortedData = [...data]
                .filter(item => item.value > 0)
                .sort((a, b) => b.value - a.value);
            
            // Prepare segments (top 8 + others if needed)
            const segments = [];
            const colors = [
                '#667eea', '#764ba2', '#4caf50', '#ff9800', '#f44336',
                '#2196f3', '#9c27b0', '#00bcd4', '#cddc39', '#ff5722'
            ];
            
            // Add top 8 segments
            for (let i = 0; i < Math.min(8, sortedData.length); i++) {
                segments.push({
                    ...sortedData[i],
                    color: colors[i % colors.length],
                    isOthers: false
                });
            }
            
            // Add "Others" segment if there are more than 8 items
            if (sortedData.length > 8) {
                let othersValue = 0;
                let othersCount = 0;
                let othersDollars = 0;
                const othersItems = [];
                
                for (let i = 8; i < sortedData.length; i++) {
                    othersValue += sortedData[i].value;
                    othersCount += sortedData[i].count || 0;
                    othersDollars += sortedData[i].dollars || 0;
                    othersItems.push(sortedData[i]);
                }
                
                if (othersValue > 0) {
                    segments.push({
                        label: t('others') || 'Others',
                        value: othersValue,
                        count: othersCount,
                        dollars: othersDollars,
                        items: othersItems,
                        color: '#555',
                        isOthers: true
                    });
                }
            }
            
            // Calculate total from SEGMENTS (not original data) to ensure consistency
            const total = segments.reduce((sum, item) => sum + item.value, 0);
            if (total === 0) return;
            
            // SIMPLIFIED DRAWING - Draw segments covering the red circle
            let currentAngle = -Math.PI / 2; // Start from top
            const labels = [];
            
            
            // Draw each segment
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                let sliceAngle;
                
                // For the last segment, make sure it closes the circle exactly
                if (i === segments.length - 1) {
                    sliceAngle = (Math.PI * 2 - Math.PI / 2) - currentAngle;
                } else {
                    sliceAngle = (segment.value / total) * 2 * Math.PI;
                }
                
                const percent = (segment.value / total * 100);
                
                
                // Draw segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = segment.color;
                ctx.fill();
                
                // Store label info for segments >= 3%
                if (percent >= 3) {
                    const labelAngle = currentAngle + sliceAngle / 2;
                    labels.push({
                        text: segment.label || 'Unknown',
                        percent: `${percent.toFixed(1)}%`,
                        angle: labelAngle,
                        color: segment.color
                    });
                }
                
                currentAngle += sliceAngle;
            }
            
            // Verify we drew a complete circle
            const finalAngle = currentAngle + Math.PI / 2; // Adjust back
            
            // Store segments data for hover interactions
            canvas.pieChartData = {
                segments: segments,
                total: total,
                centerX: centerX,
                centerY: centerY,
                radius: radius
            };
            
            // Second pass: draw labels with leader lines
            labels.forEach(label => {
                // Draw leader line
                ctx.beginPath();
                ctx.moveTo(label.lineStartX, label.lineStartY);
                ctx.lineTo(label.lineEndX, label.lineEndY);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Determine text alignment based on angle
                let textAlign = 'center';
                let xOffset = 0;
                if (Math.cos(label.angle) > 0.1) {
                    textAlign = 'left';
                    xOffset = 3;
                } else if (Math.cos(label.angle) < -0.1) {
                    textAlign = 'right';
                    xOffset = -3;
                }
                
                // Draw text
                ctx.font = '11px Arial';
                ctx.fillStyle = '#333';
                ctx.textAlign = textAlign;
                ctx.textBaseline = 'bottom';
                ctx.fillText(label.text, label.textX + xOffset, label.textY - 2);
                
                // Draw percentage
                ctx.font = 'bold 12px Arial';
                ctx.textBaseline = 'top';
                ctx.fillText(label.percent, label.textX + xOffset, label.textY + 2);
            });
            
            // Update legend using segments array
            const legendElement = document.getElementById(legendId);
            if (legendElement) {
                let legendHtml = '';
                
                // Show all segments in legend
                segments.forEach((segment, index) => {
                    const percent = ((segment.value / total) * 100).toFixed(1);
                    legendHtml += `
                        <div style="display: flex; align-items: center; min-width: 120px;">
                            <div style="width: 12px; height: 12px; background: ${segment.color}; margin-right: 6px; border-radius: 2px; flex-shrink: 0;"></div>
                            <span style="flex: 1; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100px;" title="${segment.label}">${segment.label}</span>
                            <span style="font-weight: bold; font-size: 11px; margin-left: 4px;">${percent}%</span>
                        </div>
                    `;
                });
                
                legendElement.innerHTML = legendHtml;
            }
            
            // Add mouse hover handler
            canvas.onmousemove = function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Convert to canvas coordinates (accounting for CSS scaling)
                const canvasX = (x * width) / rect.width;
                const canvasY = (y * height) / rect.height;
                
                // Check if mouse is over pie
                const dx = canvasX - centerX;
                const dy = canvasY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= radius) {
                    // Calculate angle
                    let angle = Math.atan2(dy, dx) + Math.PI / 2; // Adjust for starting position
                    if (angle < 0) angle += 2 * Math.PI;
                    
                    // Find which segment we're hovering over
                    let currentAngleCheck = 0;
                    for (let segment of segments) {
                        const sliceAngle = (segment.value / total) * 2 * Math.PI;
                        
                        if (angle >= currentAngleCheck && angle <= currentAngleCheck + sliceAngle) {
                            const chartType = canvas.pieData?.chartType || null;
                            showTooltip(e, segment, (segment.value / total) * 100, chartType);
                            canvas.style.cursor = 'pointer';
                            return;
                        }
                        currentAngleCheck += sliceAngle;
                    }
                }
                
                // Not hovering over any segment
                hideTooltip();
                canvas.style.cursor = 'default';
            };
            
            canvas.onmouseleave = function() {
                hideTooltip();
                canvas.style.cursor = 'default';
            };
        }
        
        // Function to update distribution charts
        function updateDistributionCharts() {
            // Get current chart mode (count or sum)
            const chartMode = document.querySelector('input[name="chartMode"]:checked')?.value || 'sum';
            
            const chartsSection = document.getElementById('chartsSection');
            if (!chartsSection) return;
            
            // Only show charts section if we have data
            if (!filteredSoftData && !filteredHardData && !softData && !hardData) {
                chartsSection.style.display = 'none';
                return;
            }
            
            // Show charts section
            chartsSection.style.display = 'block';
            
            // Update titles
            const protectionTitle = document.getElementById('protectionTitle');
            if (protectionTitle) protectionTitle.textContent = t('protectionStatus');
            
            // Get current data based on tab
            let dataToAnalyze = [];
            
            if (currentTab === 'soft') {
                // Use filtered data if available, otherwise use original data
                let dataSource = (filteredSoftData?.positions?.length > 0) ? filteredSoftData.positions : 
                                   (softData?.positions || []);
                
                // Apply date filter - position is active if it overlaps with the date range
                if (tableDateStart || tableDateEnd) {
                    dataSource = dataSource.filter(p => {
                        if (!p.first_dt) return false;
                        const openDate = new Date(p.first_dt);
                        const closeDate = p.last_dt ? new Date(p.last_dt) : new Date();
                        
                        // Position is active if:
                        // - opened before the end of the range AND
                        // - closed after the start of the range (or still open)
                        const rangeEnd = tableDateEnd || new Date();
                        const rangeStart = tableDateStart || new Date(0);
                        
                        return openDate <= rangeEnd && closeDate >= rangeStart;
                    });
                }
                
                dataToAnalyze = dataSource.map(p => ({
                    platform: p.platform,
                    network: p.chain,
                    token: p.collateral_token,
                    value: chartMode === 'count' ? 1 : parseFloat(p.tvl || p.collateral_usd || 0)
                }));
            } else if (currentTab === 'hard') {
                // Use filtered data if available, otherwise use original data
                let dataSource = (filteredHardData?.events?.length > 0) ? filteredHardData.events : 
                                   (hardData?.events || []);
                
                // Apply date filter
                if (tableDateStart || tableDateEnd) {
                    dataSource = dataSource.filter(e => {
                        if (!e.timestamp) return false;
                        const date = new Date(e.timestamp);
                        if (tableDateStart && date < tableDateStart) return false;
                        if (tableDateEnd && date > tableDateEnd) return false;
                        return true;
                    });
                }
                
                dataToAnalyze = dataSource.map(e => ({
                    platform: e.platform,
                    network: e.chain,
                    token: e.collateral_token,
                    value: chartMode === 'count' ? 1 : parseFloat(e.debt || 0)
                }));
            } else if (currentTab === 'comparison') {
                // For comparison tab, calculate the difference (protected funds = soft - hard)
                
                let softSource = (filteredSoftData?.positions?.length > 0) ? filteredSoftData.positions : 
                                   (softData?.positions || []);
                let hardSource = (filteredHardData?.events?.length > 0) ? filteredHardData.events : 
                                   (hardData?.events || []);
                
                // Apply date filter to soft data - position is active if it overlaps with the date range
                if (tableDateStart || tableDateEnd) {
                    softSource = softSource.filter(p => {
                        if (!p.first_dt) return false;
                        const openDate = new Date(p.first_dt);
                        const closeDate = p.last_dt ? new Date(p.last_dt) : new Date();
                        
                        // Position is active if it overlaps with the date range
                        const rangeEnd = tableDateEnd || new Date();
                        const rangeStart = tableDateStart || new Date(0);
                        
                        return openDate <= rangeEnd && closeDate >= rangeStart;
                    });
                    
                    hardSource = hardSource.filter(e => {
                        if (!e.timestamp) return false;
                        const date = new Date(e.timestamp);
                        if (tableDateStart && date < tableDateStart) return false;
                        if (tableDateEnd && date > tableDateEnd) return false;
                        return true;
                    });
                }
                
                // Aggregate soft liquidations
                const softAgg = {};
                softSource.forEach(p => {
                    const key = p.collateral_token || 'Unknown';
                    if (!softAgg[key]) {
                        softAgg[key] = { count: 0, tvl: 0, positions: [] };
                    }
                    softAgg[key].count += 1;
                    
                    // Check for data anomalies
                    const tvl = parseFloat(p.tvl || p.collateral_usd || 0);
                    
                    softAgg[key].tvl += tvl;
                    softAgg[key].positions.push({tvl, user: p.user, market: p.market_id});
                });
                
                // Aggregate hard liquidations
                const hardAgg = {};
                hardSource.forEach(e => {
                    const key = e.collateral_token || 'Unknown';
                    if (!hardAgg[key]) {
                        hardAgg[key] = { count: 0, debt: 0 };
                    }
                    hardAgg[key].count += 1;
                    
                    // Check for data anomalies
                    const debt = parseFloat(e.debt_with_discount || e.debt || 0);
                    hardAgg[key].debt += debt;
                });
                
                // Calculate differences for pie chart
                dataToAnalyze = [];
                const allTokens = new Set([...Object.keys(softAgg), ...Object.keys(hardAgg)]);
                
                allTokens.forEach(token => {
                    const soft = softAgg[token] || { count: 0, tvl: 0 };
                    const hard = hardAgg[token] || { count: 0, debt: 0 };
                    
                    // For comparison, we subtract hard from soft
                    let value;
                    if (chartMode === 'count') {
                        // For count mode, just use soft count (positions in protection)
                        // Don't subtract hard events as they are different units
                        value = soft.count;
                    } else {
                        // For sum mode, calculate protected value (TVL - losses)
                        value = Math.max(0, soft.tvl - hard.debt);
                    }
                    
                    if (value > 0) {
                        // Find the platform/network for this token from soft data
                        const samplePos = softSource.find(p => p.collateral_token === token);
                        
                        dataToAnalyze.push({
                            platform: samplePos?.platform || 'Unknown',
                            network: samplePos?.chain || 'Unknown',
                            token: token,
                            value: value
                        });
                    }
                });
            }
            
            // Aggregate by platform - store both count and dollar values
            const platformData = {};
            const networkData = {};
            const tokenData = {};
            
            // For all tabs including comparison, aggregate the dataToAnalyze normally
            {
                // First, get the original data to calculate both count and dollar values
                let originalDataForCounting = [];
                if (currentTab === 'soft') {
                    let dataSource = (filteredSoftData?.positions?.length > 0) ? filteredSoftData.positions : 
                                       (softData?.positions || []);
                    if (tableDateStart || tableDateEnd) {
                        dataSource = dataSource.filter(p => {
                            if (!p.first_dt) return false;
                            const openDate = new Date(p.first_dt);
                            const closeDate = p.last_dt ? new Date(p.last_dt) : new Date();
                            
                            // Position is active if it overlaps with the date range
                            const rangeEnd = tableDateEnd || new Date();
                            const rangeStart = tableDateStart || new Date(0);
                            
                            return openDate <= rangeEnd && closeDate >= rangeStart;
                        });
                    }
                    originalDataForCounting = dataSource;
                } else if (currentTab === 'hard') {
                    let dataSource = (filteredHardData?.events?.length > 0) ? filteredHardData.events : 
                                       (hardData?.events || []);
                    if (tableDateStart || tableDateEnd) {
                        dataSource = dataSource.filter(e => {
                            if (!e.timestamp) return false;
                            const date = new Date(e.timestamp);
                            if (tableDateStart && date < tableDateStart) return false;
                            if (tableDateEnd && date > tableDateEnd) return false;
                            return true;
                        });
                    }
                    originalDataForCounting = dataSource;
                } else if (currentTab === 'comparison') {
                    // For comparison tab, we need both soft and hard data to calculate protected amount
                    let softSource = (filteredSoftData?.positions?.length > 0) ? filteredSoftData.positions : 
                                       (softData?.positions || []);
                    let hardSource = (filteredHardData?.events?.length > 0) ? filteredHardData.events : 
                                       (hardData?.events || []);
                    
                    if (tableDateStart || tableDateEnd) {
                        softSource = softSource.filter(p => {
                            if (!p.first_dt) return false;
                            const openDate = new Date(p.first_dt);
                            const closeDate = p.last_dt ? new Date(p.last_dt) : new Date();
                            
                            // Position is active if it overlaps with the date range
                            const rangeEnd = tableDateEnd || new Date();
                            const rangeStart = tableDateStart || new Date(0);
                            
                            return openDate <= rangeEnd && closeDate >= rangeStart;
                        });
                        
                        hardSource = hardSource.filter(e => {
                            if (!e.timestamp) return false;
                            const date = new Date(e.timestamp);
                            if (tableDateStart && date < tableDateStart) return false;
                            if (tableDateEnd && date > tableDateEnd) return false;
                            return true;
                        });
                    }
                    
                    // Create a map of soft positions for quick lookup
                    const softPositionsMap = new Map();
                    softSource.forEach(pos => {
                        if (pos.user && pos.market_id) {
                            const key = `${pos.user}_${pos.market_id}`;
                            if (!softPositionsMap.has(key)) {
                                softPositionsMap.set(key, []);
                            }
                            softPositionsMap.get(key).push({
                                first_dt: pos.first_dt ? new Date(pos.first_dt) : null,
                                last_dt: pos.last_dt ? new Date(pos.last_dt) : new Date('2100-01-01'), // Far future for active positions
                                platform: pos.platform,
                                network: pos.chain,
                                token: pos.collateral_token
                            });
                        }
                    });
                    
                    
                    // Process hard liquidations and identify which ones are duplicates
                    const hardDebts = {
                        byPlatform: {},
                        byNetwork: {},
                        byToken: {}
                    };
                    const hardCounts = {
                        byPlatform: {},
                        byNetwork: {},
                        byToken: {}
                    };
                    
                    let duplicateCount = 0;
                    let uniqueCount = 0;
                    
                    hardSource.forEach(event => {
                        const debt = parseFloat(event.debt_with_discount || event.debt || 0);
                        
                        // Check if this hard liquidation corresponds to a soft position
                        let isDuplicate = false;
                        if (event.user && event.market_id && event.timestamp) {
                            const key = `${event.user}_${event.market_id}`;
                            const eventTime = new Date(event.timestamp);
                            const positions = softPositionsMap.get(key);
                            
                            if (positions) {
                                // Check if any position's lifetime contains this hard liquidation
                                isDuplicate = positions.some(pos => {
                                    return pos.first_dt && eventTime >= pos.first_dt && eventTime <= pos.last_dt;
                                });
                                
                                if (isDuplicate) {
                                    duplicateCount++;
                                } else {
                                    uniqueCount++;
                                }
                            } else {
                                uniqueCount++;
                            }
                        } else {
                            uniqueCount++;
                        }
                        
                        // Always add debt (financial loss)
                        if (event.platform) {
                            hardDebts.byPlatform[event.platform] = (hardDebts.byPlatform[event.platform] || 0) + debt;
                            // Only count if not a duplicate
                            if (!isDuplicate) {
                                hardCounts.byPlatform[event.platform] = (hardCounts.byPlatform[event.platform] || 0) + 1;
                            }
                        }
                        if (event.chain) {
                            hardDebts.byNetwork[event.chain] = (hardDebts.byNetwork[event.chain] || 0) + debt;
                            // Only count if not a duplicate
                            if (!isDuplicate) {
                                hardCounts.byNetwork[event.chain] = (hardCounts.byNetwork[event.chain] || 0) + 1;
                            }
                        }
                        if (event.collateral_token) {
                            hardDebts.byToken[event.collateral_token] = (hardDebts.byToken[event.collateral_token] || 0) + debt;
                            // Only count if not a duplicate
                            if (!isDuplicate) {
                                hardCounts.byToken[event.collateral_token] = (hardCounts.byToken[event.collateral_token] || 0) + 1;
                            }
                        }
                    });
                    
                    
                    // Now process soft liquidations and calculate protected amounts
                    softSource.forEach(item => {
                        const platform = item.platform;
                        const network = item.chain;
                        const token = item.collateral_token;
                        const softTVL = parseFloat(item.tvl || item.collateral_usd || 0);
                        
                        // For dollars, calculate protected amount (soft TVL - hard debt)
                        // For count, just use the soft position count
                        if (platform) {
                            if (!platformData[platform]) {
                                platformData[platform] = { count: 0, dollars: 0 };
                            }
                            platformData[platform].count += 1;
                            // Protected amount for this platform
                            const hardDebt = hardDebts.byPlatform[platform] || 0;
                            // Add soft TVL to platform total
                            platformData[platform].dollars += softTVL;
                        }
                        if (network) {
                            if (!networkData[network]) {
                                networkData[network] = { count: 0, dollars: 0 };
                            }
                            networkData[network].count += 1;
                            // Add soft TVL to network total
                            networkData[network].dollars += softTVL;
                        }
                        if (token) {
                            if (!tokenData[token]) {
                                tokenData[token] = { count: 0, dollars: 0 };
                            }
                            tokenData[token].count += 1;
                            // Add soft TVL to token total
                            tokenData[token].dollars += softTVL;
                        }
                    });
                    
                    // Now subtract hard debts AND counts from the totals to get protected amounts
                    Object.keys(hardDebts.byPlatform).forEach(platform => {
                        if (platformData[platform]) {
                            platformData[platform].dollars = Math.max(0, platformData[platform].dollars - hardDebts.byPlatform[platform]);
                            platformData[platform].count = Math.max(0, platformData[platform].count - (hardCounts.byPlatform[platform] || 0));
                        }
                    });
                    Object.keys(hardDebts.byNetwork).forEach(network => {
                        if (networkData[network]) {
                            networkData[network].dollars = Math.max(0, networkData[network].dollars - hardDebts.byNetwork[network]);
                            networkData[network].count = Math.max(0, networkData[network].count - (hardCounts.byNetwork[network] || 0));
                        }
                    });
                    Object.keys(hardDebts.byToken).forEach(token => {
                        if (tokenData[token]) {
                            tokenData[token].dollars = Math.max(0, tokenData[token].dollars - hardDebts.byToken[token]);
                            tokenData[token].count = Math.max(0, tokenData[token].count - (hardCounts.byToken[token] || 0));
                        }
                    });
                    
                    // Skip the regular aggregation for comparison mode
                    originalDataForCounting = [];
                }
                
                // Aggregate both count and dollar values (skip for comparison mode as we already did it)
                if (currentTab !== 'comparison') {
                    originalDataForCounting.forEach(item => {
                        const platform = item.platform;
                        const network = item.chain;
                        const token = item.collateral_token;
                        const dollarValue = currentTab === 'soft' ? 
                            parseFloat(item.tvl || item.collateral_usd || 0) :
                            parseFloat(item.debt || 0);
                    
                        if (platform) {
                            if (!platformData[platform]) {
                                platformData[platform] = { count: 0, dollars: 0 };
                            }
                            platformData[platform].count += 1;
                            platformData[platform].dollars += dollarValue;
                        }
                        if (network) {
                            if (!networkData[network]) {
                                networkData[network] = { count: 0, dollars: 0 };
                            }
                            networkData[network].count += 1;
                            networkData[network].dollars += dollarValue;
                        }
                        if (token) {
                            if (!tokenData[token]) {
                                tokenData[token] = { count: 0, dollars: 0 };
                            }
                            tokenData[token].count += 1;
                            tokenData[token].dollars += dollarValue;
                        }
                    });
                }
            }
            
            // Convert to array format and sort based on current chart mode
            const platformArray = Object.entries(platformData)
                .map(([label, data]) => ({
                    label, 
                    value: chartMode === 'count' ? data.count : data.dollars,
                    count: data.count,
                    dollars: data.dollars
                }))
                .sort((a, b) => b.value - a.value);
            
            const networkArray = Object.entries(networkData)
                .map(([label, data]) => ({
                    label, 
                    value: chartMode === 'count' ? data.count : data.dollars,
                    count: data.count,
                    dollars: data.dollars
                }))
                .sort((a, b) => b.value - a.value);
            
            const tokenArray = Object.entries(tokenData)
                .map(([label, data]) => ({
                    label, 
                    value: chartMode === 'count' ? data.count : data.dollars,
                    count: data.count,
                    dollars: data.dollars
                }))
                .sort((a, b) => b.value - a.value);
            
            // Store data globally for chart switching
            window.chartData = {
                platform: platformArray,
                network: networkArray,
                token: tokenArray
            };
            
            // Get current distribution type selection
            const currentDistributionType = document.querySelector('input[name="distributionType"]:checked')?.value || 'token';
            
            // Draw chart with current selection (not always defaulting to 'token')
            setTimeout(() => {
                switchDistributionChart(currentDistributionType);
                
                // Update protection chart
                updateProtectionChart();
            }, 100);
        }
        
        // Methodology popup functions
        function showMethodologyPopup() {
            // Always recreate modal to ensure correct language
            const existingModal = document.getElementById('methodologyModal');
            if (existingModal) {
                existingModal.remove();
            }
            createMethodologyModal();
            document.getElementById('methodologyModal').style.display = 'flex';
        }
        
        function closeMethodologyPopup() {
            const modal = document.getElementById('methodologyModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function createMethodologyModal() {
            const modalHTML = `
                <div id="methodologyModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
                    <div style="background: white; border-radius: 15px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto; margin: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); position: relative;">
                        <button onclick="closeMethodologyPopup()" style="position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666; transition: color 0.3s;" onmouseover="this.style.color='#000'" onmouseout="this.style.color='#666'">×</button>
                        
                        <h2 style="margin: 0 0 20px 0; color: #333; font-size: 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                            ${currentLang === 'en' ? 'How are Protected Funds Calculated?' : 'Как рассчитываются защищенные средства?'}
                        </h2>
                        
                        <div style="color: #555; line-height: 1.6;">
                            ${currentLang === 'en' ? `
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">What does it mean?</h3>
                                <p>Curve Finance has a unique liquidation protection system. Instead of instant collateral loss, the system gradually converts it, allowing position recovery.</p>
                                <p><strong>Protected Funds</strong> = user funds that the system saved from loss.</p>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">How are funds in liquidation protection mode (soft liquidation) calculated?</h3>
                                <p>For each position active in liquidation protection mode in the selected time period:</p>
                                <ol style="margin-left: 20px;">
                                    <li>Take the amount of collateral tokens in the position</li>
                                    <li>Multiply by the maximum oracle price during the position's time in liquidation protection mode</li>
                                    <li>Sum the values of all active positions for the selected time period</li>
                                </ol>
                                <p style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-top: 10px;">
                                    Using the maximum price shows the maximum value the position had and how much the user could have lost in a hard liquidation.
                                </p>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">How are losses from hard liquidations calculated?</h3>
                                <p>For each hard liquidation in the selected period:</p>
                                <ol style="margin-left: 20px;">
                                    <li>Take the debt amount that was liquidated plus the liquidator's discount</li>
                                    <li>Sum all such losses for the selected time period</li>
                                </ol>
                                <p>These are user losses from positions that couldn't be recovered.</p>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">Formula</h3>
                                <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace; text-align: center; margin: 15px 0;">
                                    Protected Funds = Total Value in Liquidation Protection Mode - Losses from Hard Liquidations
                                </div>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">Example</h3>
                                <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                                    <p style="margin: 5px 0;">For August 2025 (range: 01.08.2025 - 31.08.2025):</p>
                                    <p style="margin: 5px 0;">In liquidation protection mode (soft liquidation): <strong>$7.11M</strong></p>
                                    <p style="margin: 5px 0;">Losses over selected period: <strong>$676.57K</strong></p>
                                    <p style="margin: 10px 0 5px 0; font-size: 18px; color: #3b82f6;"><strong>Protected: $6.43M (90.5%)</strong></p>
                                    <p style="margin: 5px 0; font-size: 14px; color: #666;">This means 90.5% of funds were protected from loss thanks to the LLAMMA system.</p>
                                </div>
                            ` : `
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">Что это значит?</h3>
                                <p>В Curve Finance есть уникальная система защиты от ликвидаций. Вместо мгновенной потери залога, система постепенно конвертирует его, давая возможность восстановления позиции.</p>
                                <p><strong>Защищенные средства</strong> = средства пользователей, которые система уберегла от потери.</p>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">Как считаются средства в режиме защиты от ликвидации (в мягкой ликвидации)?</h3>
                                <p>Для каждой позиции находящейся в режиме защиты от ликвидации за выбранный промежуток времени:</p>
                                <ol style="margin-left: 20px;">
                                    <li>Берется количество залоговых токенов в позиции</li>
                                    <li>Умножается на максимальную цену oracle за время нахождения позиции в режиме защиты от ликвидации</li>
                                    <li>Суммируются стоимости всех активных позиций за выбранный промежуток времени</li>
                                </ol>
                                <p style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-top: 10px;">
                                    Использование максимальной цены показывает, какую максимальную стоимость имела позиция и сколько пользователь мог бы потерять при жесткой ликвидации.
                                </p>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">Как считаются потери от жестких ликвидаций?</h3>
                                <p>Для каждой жесткой ликвидации в выбранном периоде:</p>
                                <ol style="margin-left: 20px;">
                                    <li>Берется сумма долга, который был ликвидирован, плюс дисконт ликвидатору</li>
                                    <li>Суммируются все такие потери за выбранный промежуток времени</li>
                                </ol>
                                <p>Это потери пользователей, которые не смогли восстановить свои позиции.</p>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">Формула</h3>
                                <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace; text-align: center; margin: 15px 0;">
                                    Защищенные средства = Общая стоимость в режиме защиты от ликвидации - Потери от жестких ликвидаций
                                </div>
                                
                                <h3 style="color: #444; margin-top: 20px; font-size: 18px;">Пример</h3>
                                <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                                    <p style="margin: 5px 0;">За Август 2025 (диапазон: 01.08.2025 - 31.08.2025):</p>
                                    <p style="margin: 5px 0;">В режиме защиты от ликвидации (мягкой ликвидации) находится: <strong>$7.11M</strong></p>
                                    <p style="margin: 5px 0;">Потери за выбранный период: <strong>$676.57K</strong></p>
                                    <p style="margin: 10px 0 5px 0; font-size: 18px; color: #3b82f6;"><strong>Защищено: $6.43M (90.5%)</strong></p>
                                    <p style="margin: 5px 0; font-size: 14px; color: #666;">Это означает, что 90.5% средств были защищены от потери благодаря системе LLAMMA.</p>
                                </div>
                            `}
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // Close on background click
            document.getElementById('methodologyModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeMethodologyPopup();
                }
            });
        }
    </script>
</body>
</html>
